<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storagenode Pro Monitor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; transition: background-color 0.3s, color 0.3s; }
        .container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 20px; max-width: 1800px; margin: auto; }
        .card { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; display: flex; flex-direction: column; transition: background-color 0.3s; }
        .header-card { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; margin-bottom: 0; flex-wrap: wrap; }
        h1 { margin: 0; font-size: 1.8em; color: #1c1e21; }
        #node-selector { font-size: 1em; padding: 8px; border-radius: 6px; }
        #node-selector .node-link { margin: 0 8px; text-decoration: none; color: #007bff; cursor: pointer; }
        #node-selector .node-link.active { font-weight: bold; text-decoration: underline; }

        h3 { border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        .card-title { margin-top: 0; }
        .card-content { flex-grow: 1; }

        #map-card { grid-column: 1 / 8; grid-row: 2 / 4; }
        #map { height: 620px; border-radius: 8px; background-color: #aad3df; }
        #stats-card { grid-column: 8 / 13; grid-row: 2 / 3; }
        #health-card { grid-column: 8 / 13; grid-row: 3 / 4; }
        #performance-card { grid-column: 1 / 7; grid-row: 4 / 5; }
        #satellite-card { grid-column: 7 / 13; grid-row: 4 / 5; }
        #analysis-card { grid-column: 1 / 7; grid-row: 5 / 6; }
        #size-charts-card { grid-column: 7 / 13; grid-row: 5 / 6; }

        .stat { text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-label { font-size: 0.9em; color: #606770; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }

        .info-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        .info-table th, .info-table td { text-align: left; padding: 6px; border-bottom: 1px solid #eee; }
        .info-table th { color: #606770; }
        .info-table td.numeric { text-align: right; }
        .piece-id { font-family: monospace; font-size: 0.9em; }


        .chart-header { display: flex; justify-content: space-between; align-items: center; }
        .chart-header h3 { border-bottom: none; margin-bottom: 15px; }
        .toggle-link { font-size: 0.8em; cursor: pointer; text-decoration: none; color: #007bff; margin: 0 4px; }
        .toggle-link.active { font-weight: bold; text-decoration: underline; }
        #aggregation-toggles { text-align: right; margin-top: 4px; font-size: 0.9em; }


        .rate-good { color: #22c55e; }
        .rate-ok { color: #f59e0b; }
        .rate-bad { color: #ef4444; }

        /* --- Dark Mode --- */
        @media (prefers-color-scheme: dark) {
            body { background-color: #121212; color: #e0e0e0; }
            .card { background-color: #1e1e1e; box-shadow: none; border: 1px solid #333; }
            h1, h3 { color: #ffffff; }
            h3 { border-bottom-color: #444; }
            .stat-label { color: #888; }
            .info-table th, .info-table td { border-bottom-color: #333; }
            .info-table th { color: #aaa; }
            .toggle-link, #node-selector .node-link { color: #4dabf7; }
            #map { background-color: #333; }
            .leaflet-tile-pane { filter: invert(1) hue-rotate(180deg) brightness(95%) contrast(90%); }
        }
    </style>
</head>
<body>
    <div id="connection-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); color: white; display: none; justify-content: center; align-items: center; text-align: center; font-size: 1.5em; z-index: 10000;">
        <div><p>Connection Lost</p><p style="font-size: 0.6em;">Attempting to reconnect...</p></div>
    </div>
    <div class="container">
        <div class="card header-card">
            <h1>Storagenode Pro Monitor</h1>
            <div id="node-selector" title="Select a node to view or show an aggregate of all nodes">
                <span>Loading...</span>
            </div>
        </div>


        <div id="map-card" class="card"><h3 class="card-title">Live Traffic Heatmap</h3><div id="map"></div></div>

        <div id="stats-card" class="card">
            <h3 id="stats-title" class="card-title">Overall Success Rates & Speed</h3>
            <div class="stats-grid card-content">
                <div class="stat"><div id="dl-rate" class="stat-value">...%</div><div class="stat-label">Download Success</div><small>(<span id="dl-success">0</span> / <span id="dl-total">0</span>)</small></div>
                <div class="stat"><div id="ul-rate" class="stat-value">...%</div><div class="stat-label">Upload Success</div><small>(<span id="ul-success">0</span> / <span id="ul-total">0</span>)</small></div>
                <div class="stat"><div id="dl-speed" class="stat-value">... Mbps</div><div class="stat-label" id="dl-speed-label">Download Speed</div></div>
                <div class="stat"><div id="ul-speed" class="stat-value">... Mbps</div><div class="stat-label" id="ul-speed-label">Upload Speed</div></div>
            </div>
        </div>

        <div id="health-card" class="card">
             <h3 class="card-title">Node Health & History</h3>
             <div class="stats-grid">
                <div class="stat"><div id="audit-rate" class="stat-value">...%</div><div class="stat-label">Audit Success</div><small>(<span id="audit-success">0</span> / <span id="audit-total">0</span>)</small></div>
             </div>
             <table class="info-table" style="margin-top: 15px;">
                <thead><tr><th>Time</th><th style="text-align: right;">DL %</th><th style="text-align: right;">UL %</th><th style="text-align: right;">Audit %</th><th style="text-align: right;">DL Speed</th><th style="text-align: right;">UL Speed</th></tr></thead>
                <tbody id="history-body"></tbody>
            </table>
        </div>

        <div id="performance-card" class="card">
            <div class="chart-header">
                <h3 id="performance-title" class="card-title">Live Performance</h3>
                <div>
                     <div id="performance-toggles">
                        <a href="#" class="toggle-link active" data-view="rate">Rate (Mbps)</a> | <a href="#" class="toggle-link" data-view="volume">Volume (MB)</a> | <a href="#" class="toggle-link" data-view="pieces">Pieces</a> | <a href="#" class="toggle-link" data-view="concurrency">Concurrency</a>
                    </div>
                    <div id="aggregation-toggles">
                        <small>Aggregate:</small>
                        <a href="#" class="toggle-link active" data-agg="sum">Sum</a> |
                        <a href="#" class="toggle-link" data-agg="avg">Average</a>
                   </div>
                </div>
            </div>
            <div class="card-content"><canvas id="performanceChart"></canvas></div>
        </div>

        <div id="satellite-card" class="card">
            <div class="chart-header">
                <h3 id="satellite-title" class="card-title">Traffic by Satellite</h3>
                <a href="#" id="toggle-satellite-view" class="toggle-link">Show by Size</a>
            </div>
            <div class="card-content"><canvas id="satelliteChart"></canvas></div>
        </div>

        <div id="analysis-card" class="card">
            <h3 class="card-title">Network & Error Analysis</h3>
            <div class="stats-grid card-content">
                <div>
                    <h5>Top 5 Errors</h5>
                    <table class="info-table"><tbody id="error-body"></tbody></table>
                </div>
                <div>
                    <h5>Top 5 Hot Pieces</h5>
                    <table class="info-table"><tbody id="pieces-body"></tbody></table>
                </div>
                 <div>
                    <h5>Top 5 Countries (Egress)</h5>
                    <table class="info-table"><tbody id="countries-dl-body"></tbody></table>
                </div>
                 <div>
                    <h5>Top 5 Countries (Ingress)</h5>
                    <table class="info-table"><tbody id="countries-ul-body"></tbody></table>
                </div>
            </div>
        </div>

        <div id="size-charts-card" class="card">
            <div class="chart-header">
                <h3 class="card-title">Data Transfer Size Distribution</h3>
                <div>
                    <a href="#" id="toggle-size-view" class="toggle-link">Show Counts</a>
                </div>
            </div>
            <div class="card-content"><canvas id="sizeBarChart"></canvas></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // --- Advanced Heatmap Implementation ---
        class AdvancedHeatmap {
            constructor(map) {
                this.map = map;
                this.dataPoints = [];
                this.persistentHeatData = {}; // Grid-based accumulation
                this.canvas = null;
                this.ctx = null;
                this.viewMode = 'size'; // 'size' or 'pieces'
                this.maxDataAge = 5 * 60 * 1000; // 5 minutes for full visibility
                this.animationFrame = null;
                this.particleSystem = [];
                this.lastRenderTime = Date.now();
                this.gridSize = 0.5; // Degrees for heatmap grid
                
                // Event queue for temporal smoothing
                this.eventQueue = [];
                this.lastProcessedTime = null;
                this.playbackSpeed = 1.0; // Real-time playback
                this.maxQueueDelay = 10000; // Max 10 seconds delay
                this.processQueueInterval = null;
                
                // Color palettes for different data types - more subtle
                this.palettes = {
                    download: {
                        colors: ['#0066CC', '#0099FF', '#00CCFF', '#66E0FF', '#CCFFFF'],
                        label: 'Downloads (Blue)'
                    },
                    upload: {
                        colors: ['#006600', '#00AA00', '#00FF00', '#66FF66', '#CCFFCC'],
                        label: 'Uploads (Green)'
                    },
                    audit: {
                        colors: ['#660066', '#9900CC', '#CC00FF', '#E066FF', '#FFCCFF'],
                        label: 'Audits (Purple)'
                    },
                    heat: {
                        colors: ['rgba(0,0,0,0)', 'rgba(0,0,255,0.2)', 'rgba(0,255,255,0.4)',
                                'rgba(0,255,0,0.6)', 'rgba(255,255,0,0.8)', 'rgba(255,0,0,1)'],
                        label: 'Activity Intensity'
                    }
                };
                
                this.setupCanvas();
                this.startAnimation();
            }
            
            setupCanvas() {
                // Create a custom pane for the heatmap
                if (!this.map.getPane('heatmapPane')) {
                    this.map.createPane('heatmapPane');
                    this.map.getPane('heatmapPane').style.zIndex = 650;
                }
                
                // Create canvas element
                this.canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer');
                this.ctx = this.canvas.getContext('2d');
                
                // Create Leaflet canvas layer
                this.canvasLayer = L.canvasLayer({
                    pane: 'heatmapPane'
                }).addTo(this.map);
                
                const self = this;
                this.canvasLayer.delegate({
                    onDrawLayer: function(info) {
                        self.render(info);
                    }
                });
                
                // Redraw on map events
                this.map.on('moveend zoomend resize', () => this.canvasLayer.needRedraw());
            }
            
            // Queue event for temporal processing
            queueEvent(lat, lon, size, type, action, eventTimestamp) {
                const event = {
                    lat, lon, size,
                    type: action.includes('GET') ? (action === 'GET_AUDIT' ? 'audit' : 'download') : 'upload',
                    action,
                    eventTimestamp: eventTimestamp ? new Date(eventTimestamp).getTime() : Date.now(),
                    receivedTimestamp: Date.now()
                };
                
                this.eventQueue.push(event);
                
                // Sort queue by event timestamp
                this.eventQueue.sort((a, b) => a.eventTimestamp - b.eventTimestamp);
                
                // Start processing if not already running
                if (!this.processQueueInterval) {
                    this.startEventProcessor();
                }
            }
            
            startEventProcessor() {
                const processRate = 50; // Process events every 50ms for smooth animation
                
                this.processQueueInterval = setInterval(() => {
                    this.processEventQueue();
                }, processRate);
            }
            
            processEventQueue() {
                if (this.eventQueue.length === 0) return;
                
                const now = Date.now();
                
                // Process events based on their relative timing
                while (this.eventQueue.length > 0) {
                    const event = this.eventQueue[0];
                    
                    // Calculate how long this event has been waiting
                    const waitTime = now - event.receivedTimestamp;
                    
                    // Calculate the delay between event timestamp and when we received it
                    const eventDelay = event.receivedTimestamp - event.eventTimestamp;
                    
                    // If the event is very old (received more than 10s ago), process immediately
                    if (waitTime > this.maxQueueDelay) {
                        this.eventQueue.shift();
                        this.processEvent(event, true); // Skip animation
                        continue;
                    }
                    
                    // For recent events, maintain relative timing
                    // If we have multiple events from the same burst, spread them out
                    if (this.lastProcessedTime) {
                        const timeSinceLastEvent = event.eventTimestamp - this.lastProcessedTime;
                        const desiredDelay = Math.min(timeSinceLastEvent, 1000); // Max 1 second between events
                        const actualTimeSinceLastProcess = now - this.lastRenderTime;
                        
                        // If not enough time has passed since last event, wait
                        if (actualTimeSinceLastProcess < desiredDelay) {
                            break; // Wait for next cycle
                        }
                    }
                    
                    // Process this event
                    this.eventQueue.shift();
                    this.processEvent(event, false);
                    this.lastProcessedTime = event.eventTimestamp;
                    this.lastRenderTime = now;
                    
                    // Only process one event per cycle for smooth animation
                    break;
                }
            }
            
            processEvent(event, skipAnimation) {
                const now = Date.now();
                const point = {
                    lat: event.lat,
                    lon: event.lon,
                    size: event.size,
                    type: event.type,
                    timestamp: now, // Use current time for display purposes
                    pieces: 1,
                    isNew: !skipAnimation
                };
                
                this.dataPoints.push(point);
                
                // Add to persistent heatmap grid
                const gridKey = `${Math.floor(event.lat / this.gridSize) * this.gridSize}_${Math.floor(event.lon / this.gridSize) * this.gridSize}`;
                if (!this.persistentHeatData[gridKey]) {
                    this.persistentHeatData[gridKey] = {
                        lat: Math.floor(event.lat / this.gridSize) * this.gridSize,
                        lon: Math.floor(event.lon / this.gridSize) * this.gridSize,
                        value: 0,
                        timestamp: now
                    };
                }
                this.persistentHeatData[gridKey].value += this.viewMode === 'size' ? event.size : 1;
                this.persistentHeatData[gridKey].timestamp = now;
                
                // Add particle effect for new data (if not skipping animation)
                if (!skipAnimation) {
                    this.addParticle(event.lat, event.lon, event.type);
                }
                
                // Keep data points limited
                const cutoffTime = now - this.maxDataAge * 2;
                this.dataPoints = this.dataPoints.filter(p => p.timestamp > cutoffTime);
                
                // Clean old persistent data
                for (let key in this.persistentHeatData) {
                    if (now - this.persistentHeatData[key].timestamp > this.maxDataAge * 4) {
                        delete this.persistentHeatData[key];
                    }
                }
                
                this.canvasLayer.needRedraw();
            }
            
            // Backward compatibility wrapper
            addDataPoint(lat, lon, size, type, action, timestamp) {
                this.queueEvent(lat, lon, size, type, action, timestamp);
            }
            
            addParticle(lat, lon, type) {
                const colors = {
                    download: 'rgba(0, 200, 255, 0.8)',
                    upload: 'rgba(200, 255, 0, 0.8)',
                    audit: 'rgba(255, 150, 255, 0.8)'
                };
                
                this.particleSystem.push({
                    lat, lon,
                    color: colors[type],
                    size: 15,
                    opacity: 1,
                    timestamp: Date.now()
                });
            }
            
            render(info) {
                const ctx = info.canvas.getContext('2d');
                const bounds = this.map.getBounds();
                const zoom = this.map.getZoom();
                const now = Date.now();
                
                // Clear canvas
                ctx.clearRect(0, 0, info.canvas.width, info.canvas.height);
                
                // First, render persistent heatmap layer
                this.renderPersistentHeatmap(ctx, info, bounds, zoom, now);
                
                // Then render live points on top
                this.renderLivePoints(ctx, info, bounds, zoom, now);
                
                // Finally render particles
                this.renderParticles(ctx, info);
                
                ctx.globalAlpha = 1;
            }
            
            renderPersistentHeatmap(ctx, info, bounds, zoom, now) {
                // Only show persistent heatmap at higher zoom levels
                if (zoom < 5) return;
                
                // Create heat accumulation layer
                const heatmapRadius = this.getRadiusForZoom(zoom) * 2; // Larger radius for heat spread
                
                // Create temporary canvas for blending
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = info.canvas.width;
                tempCanvas.height = info.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                for (let key in this.persistentHeatData) {
                    const heat = this.persistentHeatData[key];
                    if (!bounds.contains([heat.lat, heat.lon])) continue;
                    
                    const point = info.layer._map.latLngToContainerPoint([heat.lat, heat.lon]);
                    const age = now - heat.timestamp;
                    const ageFactor = Math.max(0.1, 1 - (age / (this.maxDataAge * 4)));
                    
                    // Normalize value
                    const maxValue = this.viewMode === 'size' ? 10000000 : 100;
                    const intensity = Math.min(1, Math.sqrt(heat.value / maxValue));
                    
                    // Create gradient
                    const gradient = tempCtx.createRadialGradient(
                        point.x, point.y, 0,
                        point.x, point.y, heatmapRadius
                    );
                    
                    // Use heat colors
                    gradient.addColorStop(0, `rgba(255, 255, 0, ${intensity * ageFactor * 0.6})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 0, ${intensity * ageFactor * 0.4})`);
                    gradient.addColorStop(0.6, `rgba(255, 100, 0, ${intensity * ageFactor * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    tempCtx.fillStyle = gradient;
                    tempCtx.fillRect(point.x - heatmapRadius, point.y - heatmapRadius, heatmapRadius * 2, heatmapRadius * 2);
                }
                
                // Blend temp canvas onto main canvas
                ctx.globalAlpha = 0.7;
                ctx.globalCompositeOperation = 'screen';
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            renderLivePoints(ctx, info, bounds, zoom, now) {
                const clusterThreshold = this.getClusterThreshold(zoom);
                
                // Process and cluster data points
                const clusters = this.clusterPoints(this.dataPoints, clusterThreshold, bounds);
                
                // At low zoom levels, show aggregated heat only
                if (zoom <= 4) {
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        
                        // Calculate age factor
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));
                        
                        // Calculate intensity
                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 50000000 : 500;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));
                        
                        // Large heat gradient for aggregated view
                        const radius = 50 + intensity * 50;
                        const gradient = ctx.createRadialGradient(
                            point.x, point.y, 0,
                            point.x, point.y, radius
                        );
                        
                        // Heat colors based on intensity
                        if (intensity > 0.7) {
                            gradient.addColorStop(0, `rgba(255, 0, 0, ${ageFactor * 0.5})`);
                            gradient.addColorStop(0.5, `rgba(255, 255, 0, ${ageFactor * 0.3})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else if (intensity > 0.4) {
                            gradient.addColorStop(0, `rgba(255, 255, 0, ${ageFactor * 0.4})`);
                            gradient.addColorStop(0.5, `rgba(0, 255, 0, ${ageFactor * 0.2})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, `rgba(0, 255, 255, ${ageFactor * 0.3})`);
                            gradient.addColorStop(0.5, `rgba(0, 0, 255, ${ageFactor * 0.15})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        }
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(point.x - radius, point.y - radius, radius * 2, radius * 2);
                    });
                } else {
                    // At higher zoom levels, show individual points
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        
                        // Calculate age factor
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));
                        
                        // Small circle for individual points
                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 1000000 : 10;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));
                        
                        const radius = 3 + intensity * 5; // Much smaller: 3-8px
                        
                        // Type-based colors
                        const typeColors = {
                            download: '#0099FF',
                            upload: '#00FF00',
                            audit: '#CC00FF'
                        };
                        
                        ctx.globalAlpha = ageFactor * 0.8;
                        ctx.fillStyle = typeColors[cluster.dominantType];
                        
                        // Simple filled circle, no stroke for cleaner look
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add subtle glow for new data
                        if (cluster.hasNew) {
                            ctx.globalAlpha = ageFactor * 0.3;
                            ctx.strokeStyle = typeColors[cluster.dominantType];
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, radius + 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    });
                }
            }
            
            renderParticles(ctx, info) {
                const now = Date.now();
                const particleLifetime = 2000; // 2 seconds
                
                this.particleSystem = this.particleSystem.filter(particle => {
                    const age = now - particle.timestamp;
                    if (age > particleLifetime) return false;
                    
                    const point = info.layer._map.latLngToContainerPoint([particle.lat, particle.lon]);
                    const progress = age / particleLifetime;
                    
                    // Expand and fade
                    const size = particle.size * (1 + progress * 3);
                    const opacity = particle.opacity * (1 - progress);
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner glow
                    if (progress < 0.5) {
                        ctx.globalAlpha = opacity * 0.5;
                        ctx.fillStyle = particle.color;
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    return true;
                });
            }
            
            clusterPoints(points, threshold, bounds) {
                const clusters = [];
                const zoom = this.map.getZoom();
                
                points.forEach(point => {
                    if (!bounds.contains([point.lat, point.lon])) return;
                    
                    // Find nearby cluster
                    let merged = false;
                    for (let cluster of clusters) {
                        const dist = this.getDistance(point.lat, point.lon, cluster.lat, cluster.lon);
                        if (dist < threshold) {
                            // Merge into cluster
                            cluster.count++;
                            cluster.totalSize += point.size;
                            cluster.lat = (cluster.lat * (cluster.count - 1) + point.lat) / cluster.count;
                            cluster.lon = (cluster.lon * (cluster.count - 1) + point.lon) / cluster.count;
                            cluster.avgTimestamp = (cluster.avgTimestamp * (cluster.count - 1) + point.timestamp) / cluster.count;
                            
                            // Update type counts
                            cluster.types[point.type] = (cluster.types[point.type] || 0) + 1;
                            cluster.dominantType = Object.keys(cluster.types).reduce((a, b) =>
                                cluster.types[a] > cluster.types[b] ? a : b
                            );
                            
                            if (point.isNew) cluster.hasNew = true;
                            merged = true;
                            break;
                        }
                    }
                    
                    if (!merged) {
                        clusters.push({
                            lat: point.lat,
                            lon: point.lon,
                            count: 1,
                            totalSize: point.size,
                            avgTimestamp: point.timestamp,
                            types: { [point.type]: 1 },
                            dominantType: point.type,
                            hasNew: point.isNew
                        });
                    }
                });
                
                return clusters;
            }
            
            getDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            getRadiusForZoom(zoom) {
                // Much smaller radii for individual points
                if (zoom <= 2) return 15;
                if (zoom <= 4) return 12;
                if (zoom <= 6) return 10;
                if (zoom <= 8) return 8;
                if (zoom <= 10) return 6;
                if (zoom <= 12) return 5;
                return 4;
            }
            
            getClusterThreshold(zoom) {
                // More aggressive clustering at low zoom levels
                if (zoom <= 2) return 1000;
                if (zoom <= 4) return 500;
                if (zoom <= 6) return 200;
                if (zoom <= 8) return 100;
                if (zoom <= 10) return 50;
                if (zoom <= 12) return 20;
                return 10;
            }
            
            interpolateColors(colorArray, intensity, ageFactor) {
                // Use hex colors from palette
                const idx = Math.min(colorArray.length - 1, Math.floor(intensity * (colorArray.length - 1)));
                return colorArray[idx];
            }
            
            setViewMode(mode) {
                this.viewMode = mode;
                this.canvasLayer.needRedraw();
            }
            
            startAnimation() {
                const animate = () => {
                    const now = Date.now();
                    
                    // Mark old "new" points as not new
                    this.dataPoints.forEach(p => {
                        if (p.isNew && now - p.timestamp > 500) {
                            p.isNew = false;
                        }
                    });
                    
                    // Redraw if we have particles or new data
                    if (this.particleSystem.length > 0 || this.dataPoints.some(p => p.isNew)) {
                        this.canvasLayer.needRedraw();
                    }
                    
                    this.animationFrame = requestAnimationFrame(animate);
                };
                animate();
            }
            
            destroy() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                if (this.processQueueInterval) {
                    clearInterval(this.processQueueInterval);
                }
                if (this.canvasLayer) {
                    this.map.removeLayer(this.canvasLayer);
                }
            }
        }
        
        // Custom Canvas Layer for Leaflet
        L.CanvasLayer = L.Layer.extend({
            options: {
                pane: 'overlayPane'
            },
            
            initialize: function(options) {
                L.setOptions(this, options);
                this._map = null;
                this._canvas = null;
                this._frame = null;
            },
            
            onAdd: function(map) {
                this._map = map;
                this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-layer');
                
                const size = this._map.getSize();
                this._canvas.width = size.x;
                this._canvas.height = size.y;
                
                const animated = this._map.options.zoomAnimation && L.Browser.any3d;
                L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
                
                map.getPane(this.options.pane).appendChild(this._canvas);
                
                map.on('moveend resize zoomend', this._reset, this);
                
                if (map.options.zoomAnimation && L.Browser.any3d) {
                    map.on('zoomanim', this._animateZoom, this);
                }
                
                this._reset();
            },
            
            onRemove: function(map) {
                L.DomUtil.remove(this._canvas);
                map.off('moveend resize zoomend', this._reset, this);
                if (map.options.zoomAnimation) {
                    map.off('zoomanim', this._animateZoom, this);
                }
            },
            
            delegate: function(del) {
                this._delegate = del;
                return this;
            },
            
            needRedraw: function() {
                if (!this._frame) {
                    this._frame = L.Util.requestAnimFrame(this._redraw, this);
                }
                return this;
            },
            
            _redraw: function() {
                if (this._delegate && this._delegate.onDrawLayer) {
                    const size = this._map.getSize();
                    const bounds = this._map.getBounds();
                    const topLeft = this._map.latLngToLayerPoint(bounds.getNorthWest());
                    
                    const info = {
                        layer: this,
                        canvas: this._canvas,
                        bounds: bounds,
                        size: size,
                        topLeft: topLeft
                    };
                    
                    this._delegate.onDrawLayer(info);
                }
                this._frame = null;
            },
            
            _reset: function() {
                const topLeft = this._map.containerPointToLayerPoint([0, 0]);
                L.DomUtil.setPosition(this._canvas, topLeft);
                
                const size = this._map.getSize();
                this._canvas.width = size.x;
                this._canvas.height = size.y;
                
                this._redraw();
            },
            
            _animateZoom: function(e) {
                const scale = this._map.getZoomScale(e.zoom);
                const offset = this._map._latLngBoundsToNewLayerBounds(
                    this._map.getBounds(), e.zoom, e.center
                ).min;
                
                L.DomUtil.setTransform(this._canvas, offset, scale);
            }
        });
        
        L.canvasLayer = function(options) {
            return new L.CanvasLayer(options);
        };
        
        // --- Map Setup ---
        const map = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);
        
        // Initialize the advanced heatmap
        const heatmap = new AdvancedHeatmap(map);
        
        // Add heatmap controls with dark mode support
        const HeatmapControl = L.Control.extend({
            options: {
                position: 'topright'
            },
            
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control heatmap-control');
                
                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                container.innerHTML = `
                    <style>
                        .heatmap-control {
                            background-color: ${isDarkMode ? '#1e1e1e' : 'white'};
                            color: ${isDarkMode ? '#e0e0e0' : '#333'};
                            padding: 10px;
                            border-radius: 4px;
                            border: 1px solid ${isDarkMode ? '#444' : '#ccc'};
                        }
                        .heatmap-control h4 {
                            margin: 0 0 8px 0;
                            font-size: 13px;
                            font-weight: bold;
                        }
                        .heatmap-control label {
                            display: block;
                            cursor: pointer;
                            margin: 4px 0;
                            font-size: 12px;
                        }
                        .legend-section {
                            margin-top: 12px;
                            padding-top: 8px;
                            border-top: 1px solid ${isDarkMode ? '#444' : '#ddd'};
                        }
                        .legend-item {
                            display: flex;
                            align-items: center;
                            margin: 3px 0;
                            font-size: 11px;
                        }
                        .legend-color {
                            width: 16px;
                            height: 16px;
                            margin-right: 6px;
                            border-radius: 50%;
                            border: 1px solid ${isDarkMode ? '#666' : '#ccc'};
                        }
                        .legend-gradient {
                            width: 100%;
                            height: 10px;
                            margin: 4px 0;
                            border-radius: 2px;
                            background: linear-gradient(to right,
                                rgba(0,0,255,0.2), rgba(0,255,255,0.4),
                                rgba(0,255,0,0.6), rgba(255,255,0,0.8), rgba(255,0,0,1));
                        }
                    </style>
                    <div>
                        <h4>Heatmap View</h4>
                        <label>
                            <input type="radio" name="heatview" value="size" checked> Data Size
                        </label>
                        <label>
                            <input type="radio" name="heatview" value="pieces"> Piece Count
                        </label>
                    </div>
                    <div class="legend-section">
                        <h4>Legend</h4>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #0099FF;"></span>
                            <span>Downloads</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #00FF00;"></span>
                            <span>Uploads</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #CC00FF;"></span>
                            <span>Audits</span>
                        </div>
                        <div style="margin-top: 8px;">
                            <div style="font-size: 11px; margin-bottom: 2px;">Activity Heat:</div>
                            <div class="legend-gradient"></div>
                            <div style="font-size: 10px; display: flex; justify-content: space-between;">
                                <span>Low</span>
                                <span>High</span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Handle view mode changes
                container.addEventListener('change', function(e) {
                    if (e.target.name === 'heatview') {
                        heatmap.setViewMode(e.target.value);
                    }
                });
                
                // Update styles on dark mode change
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    const isDark = e.matches;
                    container.style.backgroundColor = isDark ? '#1e1e1e' : 'white';
                    container.style.color = isDark ? '#e0e0e0' : '#333';
                    container.style.borderColor = isDark ? '#444' : '#ccc';
                });
                
                // Prevent map interactions
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);
                
                return container;
            }
        });
        
        map.addControl(new HeatmapControl());

        // --- Constants & State ---
        const DOWNLOAD_COLOR = '#0ea5e9'; const UPLOAD_COLOR = '#22c55e';
        const PIE_CHART_COLORS = ['#36A2EB', '#FF6384', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED'];
        const PERFORMANCE_INTERVAL_MS = 2000;
        const MAX_PERF_POINTS = 150;
        let satelliteViewIsBySize = false; let lastSatelliteData = [];
        let performanceChartView = 'rate';
        let performanceAggregationMode = 'sum';
        let performanceData = {}; // Structured as { nodeName: { rate: [[],[]], ... }, ... }
        let aggregatedPerformanceData = {};
        let currentNodeView = 'Aggregate';
        let availableNodes = [];

        // --- Helper Functions ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024; const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
        function getRateClass(rate) {
            if (rate > 99.5) return 'rate-good';
            if (rate > 95) return 'rate-ok';
            return 'rate-bad';
        }

        const SATELLITE_NAMES = { '121RTSDpyNZVcEU84Ticf2L1ntiuUimbWgfATz21tuvgk3vzoA6': 'ap1', '12EayRS2V1kEsWESU9QMRseFhdxYxKicsiFmxrsLZHeLUtdps3S': 'us1', '12L9ZFwhzVpuEKMUNUqkaTLGzwY9G24tbiigLiXpmZWKwmcNDDs': 'eu1', '1wFTAgs9DP5RSnCqKV1eLf6N9wtk4EAtmN5DpSxcs8EjT69tGE': 'saltlake' };

        // --- Chart Initialization ---
        const performanceChart = new Chart(document.getElementById('performanceChart').getContext('2d'), {
            type: 'line',
            data: { datasets: [{ label: 'Ingress (Upload)', data: [], borderColor: UPLOAD_COLOR, tension: 0.2 }, { label: 'Egress (Download)', data: [], borderColor: DOWNLOAD_COLOR, tension: 0.2 }] },
            options: { scales: { x: { type: 'time', time: { unit: 'minute' } }, y: { beginAtZero: true, title: { display: true, text: 'Mbps'} } } }
        });
        const satelliteChart = new Chart(document.getElementById('satelliteChart').getContext('2d'), {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Downloads/Audits', data: [], backgroundColor: DOWNLOAD_COLOR }] },
            options: {
                indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                scales: { x: { stacked: true }, y: { stacked: true } },
                plugins: {
                    tooltip: {
                        callbacks: {
                            footer: function(tooltipItems) {
                                const context = tooltipItems[0];
                                if (lastSatelliteData.length === 0 || context.dataIndex >= lastSatelliteData.length) return '';
                                const satData = lastSatelliteData[context.dataIndex];
                                const lines = [];
                                const totalDl = satData.downloads;
                                if (totalDl > 0) { lines.push(`DL Success: ${(satData.dl_success / totalDl * 100).toFixed(2)}% (${satData.dl_success}/${totalDl})`); }
                                const totalUl = satData.uploads;
                                if (totalUl > 0) { lines.push(`UL Success: ${(satData.ul_success / totalUl * 100).toFixed(2)}% (${satData.ul_success}/${totalUl})`); }
                                const totalAudit = satData.audits;
                                if (totalAudit > 0) { lines.push(`Audit Success: ${(satData.audit_success / totalAudit * 100).toFixed(2)}% (${satData.audit_success}/${totalAudit})`); }
                                return lines;
                            }
                        }
                    }
                }
            }
        });
        // Initialize size bar chart
        const sizeBarChart = new Chart(document.getElementById('sizeBarChart').getContext('2d'), {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    { label: 'Downloads', data: [], backgroundColor: DOWNLOAD_COLOR },
                    { label: 'Uploads', data: [], backgroundColor: UPLOAD_COLOR }
                ]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'Count' },
                        stacked: true
                    },
                    y: {
                        title: { display: true, text: 'Size Bucket' },
                        stacked: true
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            footer: function(tooltipItems) {
                                const item = tooltipItems[0];
                                if (item.datasetIndex === 0) {
                                    return `${item.parsed.x} downloads in this size range`;
                                } else {
                                    return `${item.parsed.x} uploads in this size range`;
                                }
                            }
                        }
                    }
                }
            }
        });
        
        let sizeViewIsPercentage = false;

        // --- UI Update Functions ---
        function updateAllVisuals(data) {
            updateOverallStats(data.overall);
            updateSatelliteChart(data.satellites);
            updateSizeBarChart(data.download_sizes, data.upload_sizes);
            updateTitles(data.first_event_iso, data.last_event_iso);
            updateHistoricalTable(data.historical_stats);
            updateAnalysisTables(data);
        }

        function updateOverallStats(stats) {
            const totalDownloads = stats.dl_success + stats.dl_fail;
            const totalUploads = stats.ul_success + stats.ul_fail;
            const totalAudits = stats.audit_success + stats.audit_fail;
            const dlRate = totalDownloads > 0 ? (stats.dl_success / totalDownloads * 100).toFixed(2) : '100.00';
            const ulRate = totalUploads > 0 ? (stats.ul_success / totalUploads * 100).toFixed(2) : '100.00';
            const auditRate = totalAudits > 0 ? (stats.audit_success / totalAudits * 100).toFixed(2) : '100.00';

            document.getElementById('dl-rate').textContent = `${dlRate}%`;
            document.getElementById('dl-rate').className = `stat-value ${getRateClass(parseFloat(dlRate))}`;
            document.getElementById('dl-success').textContent = stats.dl_success;
            document.getElementById('dl-total').textContent = totalDownloads;

            document.getElementById('ul-rate').textContent = `${ulRate}%`;
            document.getElementById('ul-rate').className = `stat-value ${getRateClass(parseFloat(ulRate))}`;
            document.getElementById('ul-success').textContent = stats.ul_success;
            document.getElementById('ul-total').textContent = totalUploads;

            document.getElementById('dl-speed').textContent = `${(stats.avg_egress_mbps || 0).toFixed(2)} Mbps`;
            document.getElementById('ul-speed').textContent = `${(stats.avg_ingress_mbps || 0).toFixed(2)} Mbps`;

            document.getElementById('audit-rate').textContent = `${auditRate}%`;
            document.getElementById('audit-rate').className = `stat-value ${getRateClass(parseFloat(auditRate))}`;
            document.getElementById('audit-success').textContent = stats.audit_success;
            document.getElementById('audit-total').textContent = totalAudits;
        }

        function updateSatelliteChart(satStats) {
            lastSatelliteData = satStats;
            satelliteChart.data.labels = satStats.map(s => SATELLITE_NAMES[s.satellite_id] || s.satellite_id.substring(0, 12));
            if (satelliteViewIsBySize) {
                satelliteChart.options.scales.x.title.text = 'Data Transferred';
                satelliteChart.data.datasets[0].data = satStats.map(s => s.total_upload_size);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.total_download_size);
                satelliteChart.data.datasets[0].label = 'Upload Size';
                satelliteChart.data.datasets[1].label = 'Download Size';
            } else {
                satelliteChart.options.scales.x.title.text = 'Pieces';
                satelliteChart.data.datasets[0].data = satStats.map(s => s.uploads);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.downloads + s.audits);
                satelliteChart.data.datasets[0].label = 'Uploads';
                satelliteChart.data.datasets[1].label = 'Downloads/Audits';
            }
            satelliteChart.update();
        }

        function updateSizeBarChart(downloadSizes, uploadSizes) {
            // Store the data for later use with the toggle
            lastDownloadSizes = downloadSizes;
            lastUploadSizes = uploadSizes;
            
            // Create a unified set of size buckets in the correct order
            const allBuckets = ["< 1 KB", "1-4 KB", "4-16 KB", "16-64 KB", "64-256 KB", "256 KB - 1 MB", "> 1 MB"];
            
            // Initialize download and upload data with zeros
            const downloadData = new Array(allBuckets.length).fill(0);
            const uploadData = new Array(allBuckets.length).fill(0);
            
            // Map the actual data
            downloadSizes.forEach(item => {
                const index = allBuckets.indexOf(item.bucket);
                if (index !== -1) {
                    downloadData[index] = item.count;
                }
            });
            
            uploadSizes.forEach(item => {
                const index = allBuckets.indexOf(item.bucket);
                if (index !== -1) {
                    uploadData[index] = item.count;
                }
            });
            
            // Calculate percentages if needed
            if (sizeViewIsPercentage) {
                const totalDownloads = downloadData.reduce((sum, val) => sum + val, 0);
                const totalUploads = uploadData.reduce((sum, val) => sum + val, 0);
                
                if (totalDownloads > 0) {
                    downloadData.forEach((val, i) => downloadData[i] = (val / totalDownloads * 100).toFixed(1));
                }
                
                if (totalUploads > 0) {
                    uploadData.forEach((val, i) => uploadData[i] = (val / totalUploads * 100).toFixed(1));
                }
                
                sizeBarChart.options.scales.x.title.text = 'Percentage (%)';
            } else {
                sizeBarChart.options.scales.x.title.text = 'Count';
            }
            
            sizeBarChart.data.labels = allBuckets;
            sizeBarChart.data.datasets[0].data = downloadData;
            sizeBarChart.data.datasets[1].data = uploadData;
            sizeBarChart.update();
        }

        function updateTitles(firstIso, lastIso) {
            const formatTime = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let timeWindowStr = "(Last 60 Mins)";
            if (firstIso && lastIso) { timeWindowStr = `(${formatTime(new Date(firstIso))} - ${formatTime(new Date(lastIso))})`; }

            const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`;
            document.getElementById('stats-title').textContent = `Overall Success Rates & Speed${viewName} ${timeWindowStr}`;
            document.getElementById('satellite-title').textContent = `Traffic by Satellite${viewName} ${timeWindowStr}`;
            document.getElementById('dl-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Download Speed' : 'Download Speed';
            document.getElementById('ul-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Upload Speed' : 'Upload Speed';
        }

        function updateHistoricalTable(history) {
            const tbody = document.getElementById('history-body');
            tbody.innerHTML = '';
            if (!history || history.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No historical data yet.</td></tr>'; return;
            }
            for (const hour of history) {
                const totalDl = hour.dl_success + hour.dl_fail, dlRate = totalDl > 0 ? (hour.dl_success / totalDl * 100) : 100;
                const totalUl = hour.ul_success + hour.ul_fail, ulRate = totalUl > 0 ? (hour.ul_success / totalUl * 100) : 100;
                const totalAudit = hour.audit_success + hour.audit_fail, auditRate = totalAudit > 0 ? (hour.audit_success / totalAudit * 100) : 100;
                const dlSpeed = hour.dl_mbps !== undefined ? hour.dl_mbps.toFixed(2) : '...';
                const ulSpeed = hour.ul_mbps !== undefined ? hour.ul_mbps.toFixed(2) : '...';

                const row = tbody.insertRow();
                row.innerHTML = `<td>${new Date(hour.hour_timestamp).toLocaleTimeString([], { hour: 'numeric' })}</td>
                    <td class="numeric ${getRateClass(dlRate)}">${dlRate.toFixed(2)}%</td>
                    <td class="numeric ${getRateClass(ulRate)}">${ulRate.toFixed(2)}%</td>
                    <td class="numeric ${getRateClass(auditRate)}">${auditRate.toFixed(2)}%</td>
                    <td class="numeric">${dlSpeed} Mbps</td>
                    <td class="numeric">${ulSpeed} Mbps</td>`;
            }
        }

        function updateAnalysisTables(data) {
            const errorBody = document.getElementById('error-body'); errorBody.innerHTML = '';
            data.error_categories.forEach(e => errorBody.innerHTML += `<tr><td>${e.reason}</td><td>${e.count}</td></tr>`);

            const piecesBody = document.getElementById('pieces-body'); piecesBody.innerHTML = '';
            data.top_pieces.forEach(p => piecesBody.innerHTML += `<tr><td class="piece-id">${p.id.substring(0,20)}...</td><td>${p.count}</td></tr>`);

            const countriesDlBody = document.getElementById('countries-dl-body'); countriesDlBody.innerHTML = '';
            data.top_countries_dl.forEach(c => countriesDlBody.innerHTML += `<tr><td>${c.country}</td><td>${formatBytes(c.size)}</td></tr>`);

            const countriesUlBody = document.getElementById('countries-ul-body'); countriesUlBody.innerHTML = '';
            data.top_countries_ul.forEach(c => countriesUlBody.innerHTML += `<tr><td>${c.country}</td><td>${formatBytes(c.size)}</td></tr>`);
        }

        function updatePerformanceChart() {
            const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`;
            const viewTitles = { rate: 'Live Performance (Mbps)', volume: 'Data Volume (MB)', pieces: 'Pieces', concurrency: 'Active Operations' };
            const yAxisTitles = { rate: 'Mbps', volume: 'MB', pieces: 'Count', concurrency: 'Concurrent Ops' };
            document.getElementById('performance-title').textContent = viewTitles[performanceChartView] + viewName;

            document.getElementById('aggregation-toggles').style.display = (currentNodeView === 'Aggregate') ? 'block' : 'none';

            const dataToDisplay = (currentNodeView === 'Aggregate') ? aggregatedPerformanceData : performanceData[currentNodeView];
            if (!dataToDisplay) return;

            let yAxisTitle = yAxisTitles[performanceChartView];
            if(currentNodeView === 'Aggregate' && performanceAggregationMode === 'avg') {
                yAxisTitle = yAxisTitle.replace('Mbps', 'Avg. Mbps').replace('MB', 'Avg. MB');
            } else if (currentNodeView === 'Aggregate' && performanceAggregationMode === 'sum') {
                 yAxisTitle = yAxisTitle.replace('Mbps', 'Total Mbps').replace('MB', 'Total MB');
            }
            performanceChart.options.scales.y.title.text = yAxisTitle;

            const isConcurrency = performanceChartView === 'concurrency';
            let datasetsToShow = [];

            if (isConcurrency) {
                // For Concurrency view, create a single dataset.
                datasetsToShow.push({
                    label: 'Operations',
                    data: dataToDisplay.concurrency ? dataToDisplay.concurrency[0] : [],
                    borderColor: UPLOAD_COLOR,
                    tension: 0.2
                });
            } else {
                // For all other views, create two datasets.
                datasetsToShow.push({
                    label: 'Ingress (Upload)',
                    data: dataToDisplay[performanceChartView] ? dataToDisplay[performanceChartView][0] : [],
                    borderColor: UPLOAD_COLOR,
                    tension: 0.2
                });
                datasetsToShow.push({
                    label: 'Egress (Download)',
                    data: dataToDisplay[performanceChartView] ? dataToDisplay[performanceChartView][1] : [],
                    borderColor: DOWNLOAD_COLOR,
                    tension: 0.2
                });
            }

            performanceChart.data.datasets = datasetsToShow;
            performanceChart.update('none');
        }

        function initializePerformanceData(nodes) {
            const dataTemplate = () => ({ rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[], []] });
            nodes.forEach(node => {
                performanceData[node] = dataTemplate();
            });
            aggregatedPerformanceData = dataTemplate();
        }

        function recalculateAggregateData() {
            const dataTemplate = () => ({ rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[], []] });
            const newAggData = dataTemplate();
            const nodeNames = availableNodes.filter(n => n !== 'Aggregate');
            if (nodeNames.length === 0) return;

            const allTimestamps = new Set();
            nodeNames.forEach(node => {
                Object.values(performanceData[node]).forEach(seriesPair => {
                    seriesPair[0].forEach(point => allTimestamps.add(point.x.getTime()));
                });
            });

            const sortedTimestamps = Array.from(allTimestamps).sort();

            sortedTimestamps.forEach(ts => {
                const timestamp = new Date(ts);
                Object.keys(newAggData).forEach(metric => {
                    const isConcurrency = metric === 'concurrency';
                    const numSeries = isConcurrency ? 1 : 2;
                    for (let i = 0; i < numSeries; i++) {
                        let sum = 0;
                        let count = 0;
                        nodeNames.forEach(node => {
                            const point = performanceData[node][metric][i].find(p => p.x.getTime() === ts);
                            if (point) {
                                sum += point.y;
                                count++;
                            }
                        });

                        if (count > 0) {
                            const value = performanceAggregationMode === 'avg' ? sum / count : sum;
                            newAggData[metric][i].push({ x: timestamp, y: value });
                        }
                    }
                });
            });
            aggregatedPerformanceData = newAggData;
            updatePerformanceChart();
        }


        // --- Event Listeners ---
        document.getElementById('toggle-satellite-view').addEventListener('click', function(e) {
            e.preventDefault();
            satelliteViewIsBySize = !satelliteViewIsBySize;
            this.textContent = satelliteViewIsBySize ? 'Show by Pieces' : 'Show by Size';
            updateSatelliteChart(lastSatelliteData);
        });
        
        // Store the last received data for toggling between views
        let lastDownloadSizes = [];
        let lastUploadSizes = [];
        
        document.getElementById('toggle-size-view').addEventListener('click', function(e) {
            e.preventDefault();
            sizeViewIsPercentage = !sizeViewIsPercentage;
            this.textContent = sizeViewIsPercentage ? 'Show Counts' : 'Show Percentages';
            
            // Use the stored data to update the chart without fetching new data
            updateSizeBarChart(lastDownloadSizes, lastUploadSizes);
        });

        document.getElementById('performance-toggles').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.tagName === 'A') {
                performanceChartView = e.target.getAttribute('data-view');
                document.querySelectorAll('#performance-toggles .toggle-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');
                updatePerformanceChart();
            }
        });

        document.getElementById('aggregation-toggles').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.tagName === 'A') {
                performanceAggregationMode = e.target.getAttribute('data-agg');
                document.querySelectorAll('#aggregation-toggles .toggle-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');
                recalculateAggregateData();
            }
        });

        document.getElementById('node-selector').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.classList.contains('node-link')) {
                const newView = e.target.getAttribute('data-view');
                if (newView === currentNodeView) return;

                currentNodeView = newView;

                document.querySelectorAll('#node-selector .node-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');

                if (ws && ws.readyState === WebSocket.OPEN) {
                    Object.values(Chart.instances).forEach(chart => {
                        chart.data.datasets.forEach(dataset => dataset.data = []);
                        chart.update('none');
                    });
                    ws.send(JSON.stringify({ type: 'set_view', view: currentNodeView }));
                }
                updatePerformanceChart();
            }
        });

        // --- WebSocket Connection ---
        let ws;
        const connectionManager = {
            overlay: document.getElementById('connection-overlay'),
            reconnectDelay: 1000, maxReconnectDelay: 30000,
            connect: function() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);

                ws.onopen = () => { console.log("WebSocket established."); this.overlay.style.display = 'none'; this.reconnectDelay = 1000; };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    switch(data.type) {
                        case 'init':
                            availableNodes = data.nodes;
                            const selector = document.getElementById('node-selector');
                            selector.innerHTML = '';
                            data.nodes.forEach(name => {
                                const link = document.createElement('a');
                                link.href = '#';
                                link.className = 'node-link';
                                link.textContent = name;
                                link.setAttribute('data-view', name);
                                if (name === currentNodeView) {
                                    link.classList.add('active');
                                }
                                selector.appendChild(link);
                            });
                            initializePerformanceData(data.nodes.filter(n => n !== 'Aggregate'));
                            updatePerformanceChart();
                            break;
                        case 'log_entry':
                            if (data.location && data.location.lat) {
                                // Add data point with proper size normalization
                                // Size is typically in bytes, normalize it for visualization
                                const size = data.size || 1000; // Default 1KB if no size
                                // Pass the event timestamp for temporal smoothing
                                heatmap.addDataPoint(
                                    data.location.lat,
                                    data.location.lon,
                                    size,
                                    data.action || 'unknown',
                                    data.action || 'unknown',
                                    data.timestamp // Pass actual event timestamp
                                );
                            }
                            break;
                        case 'performance_update':
                            const { node_name, timestamp, ...metrics } = data;
                            const binnedTimestamp = Math.floor(new Date(timestamp).getTime() / PERFORMANCE_INTERVAL_MS) * PERFORMANCE_INTERVAL_MS;
                            const binnedNow = new Date(binnedTimestamp);

                            const nodePerf = performanceData[node_name];
                            if (!nodePerf) break;

                            const nodeNames = availableNodes.filter(n => n !== 'Aggregate');

                            function updateOrPushPoint(series, point) {
                                const lastPoint = series.length > 0 ? series[series.length - 1] : null;
                                if (lastPoint && lastPoint.x.getTime() === point.x.getTime()) {
                                    lastPoint.y = point.y;
                                } else {
                                    series.push(point);
                                }
                            }

                            const metricMap = {
                                rate: [metrics.ingress_mbps, metrics.egress_mbps],
                                volume: [metrics.ingress_bytes / 1e6, metrics.egress_bytes / 1e6],
                                pieces: [metrics.ingress_pieces, metrics.egress_pieces],
                                concurrency: [metrics.concurrency]
                            };

                            Object.keys(metricMap).forEach(metric => {
                                const values = metricMap[metric];
                                for(let i=0; i<values.length; i++) {
                                    updateOrPushPoint(nodePerf[metric][i], { x: binnedNow, y: values[i]});
                                }
                            });

                            Object.keys(aggregatedPerformanceData).forEach(metric => {
                                const isConcurrency = metric === 'concurrency';
                                const numSeries = isConcurrency ? 1 : 2;
                                for (let i = 0; i < numSeries; i++) {
                                    let sum = 0;
                                    let count = 0;
                                    nodeNames.forEach(node => {
                                        const series = performanceData[node][metric][i];
                                        const lastPoint = series.length > 0 ? series[series.length-1] : null;
                                        if(lastPoint && lastPoint.x.getTime() === binnedTimestamp) {
                                            sum += lastPoint.y;
                                            count++;
                                        }
                                    });
                                    if(count > 0) {
                                        const value = performanceAggregationMode === 'avg' ? sum / count : sum;
                                        updateOrPushPoint(aggregatedPerformanceData[metric][i], { x: binnedNow, y: value });
                                    }
                                }
                            });

                            Object.values(performanceData).forEach(nodePerf => {
                                for (const key in nodePerf) {
                                    while (nodePerf[key][0].length > MAX_PERF_POINTS) nodePerf[key][0].shift();
                                    if(nodePerf[key][1]) while (nodePerf[key][1].length > MAX_PERF_POINTS) nodePerf[key][1].shift();
                                }
                            });
                            for (const key in aggregatedPerformanceData) {
                                while (aggregatedPerformanceData[key][0].length > MAX_PERF_POINTS) aggregatedPerformanceData[key][0].shift();
                                if(aggregatedPerformanceData[key][1]) while (aggregatedPerformanceData[key][1].length > MAX_PERF_POINTS) aggregatedPerformanceData[key][1].shift();
                            }

                            updatePerformanceChart();
                            break;
                        case 'stats_update':
                            updateAllVisuals(data);
                            break;
                    }
                };

                ws.onclose = (event) => {
                    console.log(`WebSocket closed. Reconnecting...`);
                    this.overlay.style.display = 'flex';
                    setTimeout(() => this.connect(), this.reconnectDelay);
                    this.reconnectDelay = Math.min(this.maxReconnectDelay, this.reconnectDelay * 2);
                };

                ws.onerror = (err) => { console.error("WebSocket error:", err); ws.close(); };
            }
        };
        connectionManager.connect();

        // --- Dark Mode Chart Handler ---
        function updateChartColors(isDarkMode) {
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#e0e0e0' : '#333';

            Chart.defaults.color = textColor;
            Chart.defaults.borderColor = gridColor;

            for (const id in Chart.instances) {
                const chart = Chart.instances[id];
                if(chart.options.plugins.tooltip) {
                    chart.options.plugins.tooltip.titleColor = textColor;
                    chart.options.plugins.tooltip.bodyColor = textColor;
                    chart.options.plugins.tooltip.footerColor = textColor;
                }
                chart.update();
            }
        }

        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        updateChartColors(darkModeMediaQuery.matches);
        darkModeMediaQuery.addEventListener('change', e => updateChartColors(e.matches));
    </script>
</body>
</html>
