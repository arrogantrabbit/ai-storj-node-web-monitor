<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex">
    <title>Storagenode Pro Monitor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; transition: background-color: 0.3s, color: 0.3s; }
        .container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 20px; max-width: 1800px; margin: auto; }
        .card { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; display: flex; flex-direction: column; transition: background-color: 0.3s, grid-column 0.3s ease, grid-row 0.3s ease; }
        .header-card { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; margin-bottom: 0; flex-wrap: wrap; gap: 20px; }
        h1 { margin: 0; font-size: 1.8em; color: #1c1e21; }

        .header-controls { display: flex; align-items: center; gap: 20px; }
        #node-selector { font-size: 1em; padding: 8px; border-radius: 6px; }
        #node-selector .node-link { margin: 2px 4px; padding: 4px 8px; border-radius: 4px; border: 1px solid transparent; display: inline-block; text-decoration: none; color: #007bff; cursor: pointer; }
        #node-selector .node-link:hover { background-color: rgba(0,0,0,0.05); border-color: #ddd; }
        #node-selector .node-link.active { font-weight: bold; background-color: #007bff; color: white; border-color: #007bff; }

        @media (prefers-color-scheme: dark) {
            #node-selector .node-link:hover { background-color: rgba(255,255,255,0.1); border-color: #444; }
            #node-selector .node-link.active { background-color: #4dabf7; color: #121212; border-color: #4dabf7; }
        }

        h3 { border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        h5 { margin-top: 0; margin-bottom: 10px; font-size: 1em; }
        .card-title { margin-top: 0; }
        .card-content { flex-grow: 1; }
        .table-container { overflow-x: auto; }

        /* Note: grid-column and grid-row for cards are now set dynamically by JavaScript */
        #map { height: 620px; border-radius: 8px; background-color: #aad3df; }

        .stat { text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-label { font-size: 0.9em; color: #606770; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; }

        .info-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        .info-table th, .info-table td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; vertical-align: top; }
        .info-table th { color: #606770; font-weight: 600; }
        .info-table th.numeric, .info-table td.numeric { text-align: right; white-space: nowrap; }
        .piece-id { font-family: monospace; font-size: 0.9em; white-space: nowrap; }

        /* Styles for sortable table headers */
        .info-table th[data-column] { cursor: pointer; position: relative; padding-right: 20px; }
        .info-table th[data-column]::after { content: ''; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); border: 4px solid transparent; opacity: 0.3; }
        .info-table th[data-column].sort-asc::after { border-bottom-color: #333; }
        .info-table th[data-column].sort-desc::after { border-top-color: #333; }
        .info-table th[data-column]:hover::after { opacity: 0.7; }
        .info-table th[data-column].sort-asc::after, .info-table th[data-column].sort-desc::after { opacity: 1; }

        .chart-header { display: flex; justify-content: space-between; align-items: center; }
        .chart-header h3 { border-bottom: none; margin-bottom: 15px; }
        .toggle-link { font-size: 0.8em; cursor: pointer; text-decoration: none; color: #007bff; margin: 0 4px; }
        .toggle-link.active { font-weight: bold; text-decoration: underline; }
        .toggle-link.disabled { color: #888; cursor: not-allowed; text-decoration: none; }
        #aggregation-toggles { text-align: right; margin-top: 4px; font-size: 0.9em; }

        #analysis-card .stats-grid {
            grid-template-columns: 2.5fr 2fr 1.5fr 1.5fr;
            gap: 30px;
        }
        #analysis-card .reason-cell {
            white-space: normal;
            word-break: break-word;
        }
        #performance-card .card-content,
        #satellite-card .card-content {
            position: relative;
            height: 350px;
        }
        #size-charts-card .card-content {
            position: relative;
            height: 600px;
        }


        .rate-good { color: #22c55e; }
        .rate-ok { color: #f59e0b; }
        .rate-bad { color: #ef4444; }

        .card-header-flex { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        .card-header-flex .card-title { margin-bottom: 0; border-bottom: none; padding-bottom: 0; }
        #toggle-map-size-btn { background: none; border: 1px solid transparent; border-radius: 4px; cursor: pointer; font-size: 1.5em; padding: 0; line-height: 1; color: #606770; transition: background-color 0.2s; }
        #toggle-map-size-btn:hover { background-color: rgba(0,0,0,0.05); border-color: #ddd; }

        body.map-maximized { overflow: hidden; }

        #map-card.maximized { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; margin: 0; border-radius: 0; padding: 15px; box-sizing: border-box; }
        #map-card.maximized .card-header-flex { margin-bottom: 10px; }
        #map-card.maximized #map { height: calc(100% - 50px); }

        .card.is-hidden { display: none; }

        /* --- New Display Menu Styles --- */
        #display-menu-container { position: relative; }
        #display-menu-btn {
            font-size: 0.9em;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #display-menu-btn:hover { background-color: #e9ecef; }
        #display-menu-dropdown {
            position: absolute;
            top: calc(100% + 5px);
            right: 0;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            z-index: 1001;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }
        #display-menu-dropdown.visible { display: block; }
        #display-menu-dropdown h5 { margin-top: 0; margin-bottom: 10px; font-size: 1em; color: #333; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        #display-menu-dropdown label { display: flex; align-items: center; padding: 6px 0; cursor: pointer; user-select: none; font-size: 0.95em; }
        #display-menu-dropdown label input { margin-right: 10px; transform: scale(1.1); }

        /* --- Dark Mode --- */
        @media (prefers-color-scheme: dark) {
            body { background-color: #121212; color: #e0e0e0; }
            .card { background-color: #1e1e1e; box-shadow: none; border: 1px solid #333; }
            h1, h3, h5 { color: #ffffff; }
            h3, .card-header-flex { border-bottom-color: #444; }
            .stat-label { color: #888; }
            .info-table th, .info-table td { border-bottom-color: #333; }
            .info-table th { color: #aaa; }
            .info-table th[data-column].sort-asc::after { border-bottom-color: #aaa; }
            .info-table th[data-column].sort-desc::after { border-top-color: #aaa; }
            .toggle-link, #node-selector .node-link { color: #4dabf7; }
            .toggle-link.disabled { color: #555; }
            #map { background-color: #333; }
            .leaflet-tile-pane { filter: invert(1) hue-rotate(180deg) brightness(95%) contrast(90%); }
            #toggle-map-size-btn { color: #aaa; }
            #toggle-map-size-btn:hover { background-color: rgba(255,255,255,0.1); border-color: #444; }

            /* Dark mode for display menu */
            #display-menu-btn { background: #343a40; border-color: #495057; color: #e0e0e0; }
            #display-menu-btn:hover { background: #495057; }
            #display-menu-dropdown { background: #2a2a2a; border-color: #555; }
            #display-menu-dropdown h5 { color: #fff; border-bottom-color: #444; }
        }
    </style>
</head>
<body>
    <div id="connection-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); color: white; display: none; justify-content: center; align-items: center; text-align: center; font-size: 1.5em; z-index: 10000;">
        <div><p>Connection Lost</p><p style="font-size: 0.6em;">Attempting to reconnect...</p></div>
    </div>
    <div class="container">
        <div class="card header-card">
            <h1>Storagenode Pro Monitor</h1>
            <div class="header-controls">
                <div id="node-selector" title="Select a node to view or show an aggregate of all nodes">
                    <span>Loading...</span>
                </div>
                <div id="display-menu-container">
                    <button id="display-menu-btn">Options</button>
                    <div id="display-menu-dropdown"></div>
                </div>
            </div>
        </div>

        <div id="map-card" class="card">
            <div class="card-header-flex">
                <h3 class="card-title">Live Traffic Heatmap</h3>
                <button id="toggle-map-size-btn" title="Maximize Map">&#x26F6;</button>
            </div>
            <div id="map"></div>
        </div>

        <div id="stats-card" class="card">
            <h3 id="stats-title" class="card-title">Overall Success Rates & Speed</h3>
            <div class="stats-grid card-content">
                <div class="stat"><div id="dl-rate" class="stat-value">...%</div><div class="stat-label">Download Success</div><small>(<span id="dl-success">0</span> / <span id="dl-total">0</span>)</small></div>
                <div class="stat"><div id="ul-rate" class="stat-value">...%</div><div class="stat-label">Upload Success</div><small>(<span id="ul-success">0</span> / <span id="ul-total">0</span>)</small></div>
                <div class="stat"><div id="dl-speed" class="stat-value">... Mbps</div><div class="stat-label" id="dl-speed-label">Download Speed</div></div>
                <div class="stat"><div id="ul-speed" class="stat-value">... Mbps</div><div class="stat-label" id="ul-speed-label">Upload Speed</div></div>
            </div>
        </div>

        <div id="health-card" class="card">
             <h3 class="card-title">Node Health & History</h3>
             <div class="stats-grid">
                <div class="stat"><div id="audit-rate" class="stat-value">...%</div><div class="stat-label">Audit Success</div><small>(<span id="audit-success">0</span> / <span id="audit-total">0</span>)</small></div>
                <div class="stat"><div class="stat-value">&nbsp;</div><div class="stat-label">&nbsp;</div></div>
             </div>
             <div class="table-container" style="margin-top: 15px;">
                 <table class="info-table">
                    <thead><tr><th>Time</th><th class="numeric">DL %</th><th class="numeric">UL %</th><th class="numeric">Audit %</th><th class="numeric">DL Speed</th><th class="numeric">UL Speed</th></tr></thead>
                    <tbody id="history-body"></tbody>
                </table>
             </div>
        </div>

        <div id="performance-card" class="card">
            <div class="chart-header">
                <h3 id="performance-title" class="card-title">Live Performance</h3>
                <div>
                     <div id="performance-toggles">
                        <a href="#" class="toggle-link active" data-view="rate">Rate (Mbps)</a> | <a href="#" class="toggle-link" data-view="volume">Volume (MB)</a> | <a href="#" class="toggle-link" data-view="pieces">Pieces</a> | <a href="#" class="toggle-link" data-view="concurrency">Concurrency</a>
                    </div>
                    <div id="time-range-toggles" style="text-align: right; font-size: 0.9em; margin-top: 4px;">
                        <small>Range:</small>
                        <a href="#" class="toggle-link active" data-range="5m">5m</a> |
                        <a href="#" class="toggle-link" data-range="30m">30m</a> |
                        <a href="#" class="toggle-link" data-range="1h">1h</a> |
                        <a href="#" class="toggle-link" data-range="6h">6h</a> |
                        <a href="#" class="toggle-link" data-range="24h">24h</a>
                    </div>
                    <div id="aggregation-toggles">
                        <small>Aggregate:</small>
                        <a href="#" class="toggle-link active" data-agg="sum">Sum</a> |
                        <a href="#" class="toggle-link" data-agg="avg">Average</a>
                   </div>
                </div>
            </div>
            <div class="card-content"><canvas id="performanceChart"></canvas></div>
        </div>

        <div id="satellite-card" class="card">

      <div class="chart-header">
                <h3 id="satellite-title" class="card-title">Traffic by Satellite</h3>
                <a href="#" id="toggle-satellite-view" class="toggle-link">Show by Size</a>
            </div>
            <div class="card-content"><canvas id="satelliteChart"></canvas></div>
        </div>

        <div id="analysis-card" class="card">
            <h3 class="card-title">Network & Error Analysis</h3>
            <div class="stats-grid card-content">
                <div>
                    <h5>Top 10 Errors</h5>
                    <table class="info-table">
                        <thead><tr><th>Reason</th><th class="numeric">Count</th></tr></thead>
                        <tbody id="error-body"></tbody>
                    </table>
                </div>
                <div>
                    <h5>Top 10 Hot Pieces</h5>
                    <table class="info-table">
                        <thead><tr><th>Piece ID</th><th class="numeric">Count</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="pieces-body"></tbody>
                    </table>
                </div>
                 <div>
                    <h5>Top 10 Countries (Egress)</h5>
                     <table class="info-table">
                        <thead><tr><th>Country</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="countries-dl-body"></tbody>
                    </table>
                </div>
                 <div>
                    <h5>Top 10 Countries (Ingress)</h5>
                     <table class="info-table">
                        <thead><tr><th>Country</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="countries-ul-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="size-charts-card" class="card">
            <div class="chart-header">
                <h3 id="size-chart-title" class="card-title">Data Transfer Size Distribution</h3>
                <div id="size-view-toggles">
                    <small>Show:</small>
                    <a href="#" class="toggle-link active" data-view="counts">Counts</a> |
                    <a href="#" class="toggle-link" data-view="percentages">Percentages</a> |
                    <a href="#" class="toggle-link" data-view="rates">Success Rate</a>
                </div>
            </div>
            <div class="card-content"><canvas id="sizeBarChart"></canvas></div>
        </div>

        <div id="hashstore-chart-card" class="card">
            <div class="card-header-flex">
                <h3 id="hashstore-chart-title" class="card-title">Hashstore Compaction Trends</h3>
                <div id="hashstore-filters" style="display: flex; gap: 15px; align-items: center; font-size: 0.9em;">
                    <!-- JS populates this -->
                </div>
            </div>
            <div class="card-content" style="position: relative; height:300px;">
                <canvas id="hashstoreChart"></canvas>
            </div>
        </div>

        <div id="hashstore-card" class="card">
            <div class="card-header-flex">
                <h3 id="hashstore-title" class="card-title">Hashstore Compaction Details</h3>
            </div>
            <div class="card-content table-container">
                <table class="info-table">
                    <thead>
                        <tr>
                            <th data-column="node_name">Node</th>
                            <th data-column="satellite">Satellite</th>
                            <th data-column="store">Store</th>
                            <th data-column="last_run_iso">Last Run</th>
                            <th class="numeric" data-column="duration">Duration</th>
                            <th class="numeric" data-column="data_reclaimed_bytes">Data Reclaimed</th>
                            <th class="numeric" data-column="data_rewritten_bytes">Data Rewritten</th>
                            <th class="numeric" data-column="reclaim_efficiency">Reclaim Efficiency</th>
                            <th class="numeric" data-column="throughput">Throughput (MB/s)</th>
                            <th class="numeric" data-column="table_load">Table Load</th>
                            <th class="numeric" data-column="trash_percent">Trash %</th>
                        </tr>
                    </thead>
                    <tbody id="hashstore-body">
                        <!-- JS populates this -->
                    </tbody>
                    <tfoot id="hashstore-foot">
                        <!-- JS populates this -->
                    </tfoot>
                </table>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // --- Advanced Heatmap Implementation ---
        class AdvancedHeatmap {
            constructor(map) {
                this.map = map;
                this.dataPoints = [];
                this.persistentHeatData = {}; // Grid-based accumulation
                this.canvas = null;
                this.ctx = null;
                this.viewMode = 'size'; // 'size' or 'pieces'
                this.maxDataAge = 5 * 60 * 1000; // 5 minutes for full visibility
                this.animationFrame = null;
                this.particleSystem = [];
                this.lastRenderTime = Date.now();
                this.gridSize = 0.5; // Degrees for heatmap grid
                this.isPaused = false;

                this.setupCanvas();
                this.startAnimation();
            }

            setupCanvas() {
                // Create a custom pane for the heatmap
                if (!this.map.getPane('heatmapPane')) {
                    this.map.createPane('heatmapPane');
                    this.map.getPane('heatmapPane').style.zIndex = 650;
                }

                // Create canvas element
                this.canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer');
                this.ctx = this.canvas.getContext('2d');

                // Create Leaflet canvas layer
                this.canvasLayer = L.canvasLayer({
                    pane: 'heatmapPane'
                }).addTo(this.map);

                const self = this;
                this.canvasLayer.delegate({
                    onDrawLayer: function(info) {
                        self.render(info);
                    }
                });

                // Redraw on map events
                this.map.on('moveend zoomend resize', () => this.canvasLayer.needRedraw());
            }

            processEvent(event) {
                const now = Date.now();
                const point = {
                    lat: event.lat,
                    lon: event.lon,
                    size: event.size,
                    type: event.type,
                    timestamp: now, // Use current time for display purposes
                    pieces: 1,
                    isNew: true
                };

                this.dataPoints.push(point);

                // Add to persistent heatmap grid
                const gridKey = `${Math.floor(event.lat / this.gridSize) * this.gridSize}_${Math.floor(event.lon / this.gridSize) * this.gridSize}`;
                if (!this.persistentHeatData[gridKey]) {
                    this.persistentHeatData[gridKey] = {
                        lat: Math.floor(event.lat / this.gridSize) * this.gridSize,
                        lon: Math.floor(event.lon / this.gridSize) * this.gridSize,
                        value: 0,
                        timestamp: now
                    };
                }
                this.persistentHeatData[gridKey].value += this.viewMode === 'size' ? event.size : 1;
                this.persistentHeatData[gridKey].timestamp = now;

                // Add particle effect for new data
                this.addParticle(event.lat, event.lon, event.type);

                // Keep data points limited
                const cutoffTime = now - this.maxDataAge * 2;
                this.dataPoints = this.dataPoints.filter(p => p.timestamp > cutoffTime);

                // Clean old persistent data
                for (let key in this.persistentHeatData) {
                    if (now - this.persistentHeatData[key].timestamp > this.maxDataAge * 4) {
                        delete this.persistentHeatData[key];
                    }
                }

                this.canvasLayer.needRedraw();
            }

            clearData() {
                this.dataPoints = [];
                this.persistentHeatData = {};
                this.particleSystem = [];
                this.canvasLayer.needRedraw(); // Force a redraw to clear the canvas
            }

            // Simplified entry point for new data
            addDataPoint(lat, lon, size, type, action, timestamp) {
                 const event = {
                    lat, lon, size,
                    type: action.includes('GET') ? (action === 'GET_AUDIT' ? 'audit' : 'download') : 'upload',
                    action,
                    eventTimestamp: timestamp ? new Date(timestamp).getTime() : Date.now()
                };
                this.processEvent(event);
            }

            addParticle(lat, lon, type) {
                const colors = {
                    download: 'rgba(0, 200, 255, 0.8)',
                    upload: 'rgba(200, 255, 0, 0.8)',
                    audit: 'rgba(255, 150, 255, 0.8)'
                };

                this.particleSystem.push({
                    lat, lon,
                    color: colors[type],
                    size: 15,
                    opacity: 1,
                    timestamp: Date.now()
                });
            }

            render(info) {
                const ctx = info.canvas.getContext('2d');
                const bounds = this.map.getBounds();
                const zoom = this.map.getZoom();
                const now = Date.now();

                // Clear canvas
                ctx.clearRect(0, 0, info.canvas.width, info.canvas.height);

                // First, render persistent heatmap layer
                this.renderPersistentHeatmap(ctx, info, bounds, zoom, now);

                // Then render live points on top
                this.renderLivePoints(ctx, info, bounds, zoom, now);

                // Finally render particles
                this.renderParticles(ctx, info);

                ctx.globalAlpha = 1;
            }

            renderPersistentHeatmap(ctx, info, bounds, zoom, now) {
                if (zoom < 5) return;

                const heatmapRadius = this.getRadiusForZoom(zoom) * 2;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = info.canvas.width;
                tempCanvas.height = info.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                for (let key in this.persistentHeatData) {
                    const heat = this.persistentHeatData[key];
                    if (!bounds.contains([heat.lat, heat.lon])) continue;

                    const point = info.layer._map.latLngToContainerPoint([heat.lat, heat.lon]);
                    const age = now - heat.timestamp;
                    const ageFactor = Math.max(0.1, 1 - (age / (this.maxDataAge * 4)));

                    const maxValue = this.viewMode === 'size' ? 10000000 : 100;
                    const intensity = Math.min(1, Math.sqrt(heat.value / maxValue));

                    const gradient = tempCtx.createRadialGradient(point.x, point.y, 0, point.x, point.y, heatmapRadius);
                    gradient.addColorStop(0, `rgba(255, 255, 0, ${intensity * ageFactor * 0.75})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 0, ${intensity * ageFactor * 0.5})`);
                    gradient.addColorStop(0.6, `rgba(255, 100, 0, ${intensity * ageFactor * 0.25})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                    tempCtx.fillStyle = gradient;
                    tempCtx.fillRect(point.x - heatmapRadius, point.y - heatmapRadius, heatmapRadius * 2, heatmapRadius * 2);
                }

                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                ctx.globalCompositeOperation = isDarkMode ? 'screen' : 'lighter';
                ctx.globalAlpha = isDarkMode ? 1.0 : 0.7;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            }

            renderLivePoints(ctx, info, bounds, zoom, now) {
                const clusterThreshold = this.getClusterThreshold(zoom);
                const clusters = this.clusterPoints(this.dataPoints, clusterThreshold, bounds);
                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

                if (zoom <= 4) {
                    ctx.globalCompositeOperation = isDarkMode ? 'screen' : 'lighter';
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));

                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 50000000 : 500;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));

                        const radius = 50 + intensity * 50;
                        const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);

                        if (intensity > 0.7) {
                            gradient.addColorStop(0, `rgba(255, 0, 0, ${ageFactor * 0.6})`);
                            gradient.addColorStop(0.5, `rgba(255, 255, 0, ${ageFactor * 0.4})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else if (intensity > 0.4) {
                            gradient.addColorStop(0, `rgba(255, 255, 0, ${ageFactor * 0.5})`);
                            gradient.addColorStop(0.5, `rgba(0, 255, 0, ${ageFactor * 0.25})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, `rgba(0, 255, 255, ${ageFactor * 0.4})`);
                            gradient.addColorStop(0.5, `rgba(0, 0, 255, ${ageFactor * 0.2})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        }
                        ctx.fillStyle = gradient;
                        ctx.fillRect(point.x - radius, point.y - radius, radius * 2, radius * 2);
                    });
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));
                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 1000000 : 10;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));
                        const radius = 3 + intensity * 5;
                        const typeColors = { download: '#0099FF', upload: '#00FF00', audit: '#CC00FF' };
                        ctx.globalAlpha = ageFactor * 0.9;
                        ctx.fillStyle = typeColors[cluster.dominantType];
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        if (cluster.hasNew) {
                            ctx.globalAlpha = ageFactor * 0.5;
                            ctx.strokeStyle = typeColors[cluster.dominantType];
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, radius + 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    });
                }
            }

            renderParticles(ctx, info) {
                const now = Date.now();
                const particleLifetime = 2000;

                this.particleSystem = this.particleSystem.filter(particle => {
                    const age = now - particle.timestamp;
                    if (age > particleLifetime) return false;

                    const point = info.layer._map.latLngToContainerPoint([particle.lat, particle.lon]);
                    const progress = age / particleLifetime;
                    const size = particle.size * (1 + progress * 3);
                    const opacity = particle.opacity * (1 - progress);
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = 1.5; // Restored thinner line for original look
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.stroke(); // Only stroke, no fill
                    ctx.restore();
                    return true;
                });
            }

            clusterPoints(points, threshold, bounds) {
                const clusters = [];
                points.forEach(point => {
                    if (!bounds.contains([point.lat, point.lon])) return;
                    let merged = false;
                    for (let cluster of clusters) {
                        const dist = this.getDistance(point.lat, point.lon, cluster.lat, cluster.lon);
                        if (dist < threshold) {
                            cluster.count++;
                            cluster.totalSize += point.size;
                            cluster.lat = (cluster.lat * (cluster.count - 1) + point.lat) / cluster.count;
                            cluster.lon = (cluster.lon * (cluster.count - 1) + point.lon) / cluster.count;
                            cluster.avgTimestamp = (cluster.avgTimestamp * (cluster.count - 1) + point.timestamp) / cluster.count;
                            cluster.types[point.type] = (cluster.types[point.type] || 0) + 1;
                            cluster.dominantType = Object.keys(cluster.types).reduce((a, b) => cluster.types[a] > cluster.types[b] ? a : b);
                            if (point.isNew) cluster.hasNew = true;
                            merged = true;
                            break;
                        }
                    }
                    if (!merged) {
                        clusters.push({ lat: point.lat, lon: point.lon, count: 1, totalSize: point.size, avgTimestamp: point.timestamp, types: { [point.type]: 1 }, dominantType: point.type, hasNew: point.isNew });
                    }
                });
                return clusters;
            }

            getDistance(lat1, lon1, lat2, lon2) {
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            getRadiusForZoom = zoom => (zoom <= 2) ? 15 : (zoom <= 4) ? 12 : (zoom <= 6) ? 10 : (zoom <= 8) ? 8 : (zoom <= 10) ? 6 : (zoom <= 12) ? 5 : 4;
            getClusterThreshold = zoom => (zoom <= 2) ? 1000 : (zoom <= 4) ? 500 : (zoom <= 6) ? 200 : (zoom <= 8) ? 100 : (zoom <= 10) ? 50 : (zoom <= 12) ? 20 : 10;

            setViewMode(mode) { this.viewMode = mode; this.canvasLayer.needRedraw(); }

            startAnimation() {
                const animate = () => {
                    if (this.isPaused) {
                        this.animationFrame = null; // Let the loop die
                        return;
                    }
                    const now = Date.now();
                    this.dataPoints.forEach(p => { if (p.isNew && now - p.timestamp > 500) p.isNew = false; });
                    if (this.particleSystem.length > 0 || this.dataPoints.some(p => p.isNew)) { this.canvasLayer.needRedraw(); }
                    this.animationFrame = requestAnimationFrame(animate);
                };
                if (!this.animationFrame) { // Prevent multiple loops
                    this.animationFrame = requestAnimationFrame(animate);
                }
            }

            pause() {
                this.isPaused = true;
            }

            resume() {
                if (this.isPaused) {
                    this.isPaused = false;
                    this.startAnimation(); // Restart loop if it died
                    this.canvasLayer.needRedraw(); // Force a redraw on resume
                }
            }

            destroy() {
                this.isPaused = true; // This will stop the animation loop
                if (this.canvasLayer) this.map.removeLayer(this.canvasLayer);
            }
        }

        L.CanvasLayer = L.Layer.extend({
            options: { pane: 'overlayPane' },
            initialize: function(options) { L.setOptions(this, options); },
            onAdd: function(map) { this._map = map; this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-layer'); const size = this._map.getSize(); this._canvas.width = size.x; this._canvas.height = size.y; const animated = this._map.options.zoomAnimation && L.Browser.any3d; L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide')); map.getPane(this.options.pane).appendChild(this._canvas); map.on('move moveend resize zoomend', this._reset, this); if (map.options.zoomAnimation && L.Browser.any3d) { map.on('zoomanim', this._animateZoom, this); } this._reset(); },
            onRemove: function(map) { L.DomUtil.remove(this._canvas); map.off('moveend resize zoomend', this._reset, this); if (map.options.zoomAnimation) { map.off('zoomanim', this._animateZoom, this); } },
            delegate: function(del) { this._delegate = del; return this; },
            needRedraw: function() { if (!this._frame) { this._frame = L.Util.requestAnimFrame(this._redraw, this); } return this; },
            _redraw: function() { if (this._delegate && this._delegate.onDrawLayer) { const info = { layer: this, canvas: this._canvas, bounds: this._map.getBounds(), size: this._map.getSize(), topLeft: this._map.latLngToLayerPoint(this._map.getBounds().getNorthWest()) }; this._delegate.onDrawLayer(info); } this._frame = null; },
            _reset: function() { const topLeft = this._map.containerPointToLayerPoint([0, 0]); L.DomUtil.setPosition(this._canvas, topLeft); const size = this._map.getSize(); this._canvas.width = size.x; this._canvas.height = size.y; this._redraw(); },
            _animateZoom: function(e) { const scale = this._map.getZoomScale(e.zoom); const offset = this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min; L.DomUtil.setTransform(this._canvas, offset, scale); }
        });
        L.canvasLayer = options => new L.CanvasLayer(options);

        // --- Map Setup (Reverted to single tile layer) ---
        const map = L.map('map').setView([20, 0], 2);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 18
        }).addTo(map);

        const heatmap = new AdvancedHeatmap(map);

        const HeatmapControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) { const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control heatmap-control'); const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; container.innerHTML = `<style>.heatmap-control{background-color:${isDarkMode?'#1e1e1e':'white'};color:${isDarkMode?'#e0e0e0':'#333'};padding:10px;border-radius:4px;border:1px solid ${isDarkMode?'#444':'#ccc'}}.heatmap-control h4{margin:0 0 8px 0;font-size:13px;font-weight:bold}.heatmap-control label{display:block;cursor:pointer;margin:4px 0;font-size:12px}.legend-section{margin-top:12px;padding-top:8px;border-top:1px solid ${isDarkMode?'#444':'#ddd'}}.legend-item{display:flex;align-items:center;margin:3px 0;font-size:11px}.legend-color{width:16px;height:16px;margin-right:6px;border-radius:50%;border:1px solid ${isDarkMode?'#666':'#ccc'}}.legend-gradient{width:100%;height:10px;margin:4px 0;border-radius:2px;background:linear-gradient(to right,rgba(0,0,255,0.2),rgba(0,255,255,0.4),rgba(0,255,0,0.6),rgba(255,255,0,0.8),rgba(255,0,0,1))}</style><div><h4>Heatmap View</h4><label><input type="radio" name="heatview" value="size" checked> Data Size</label><label><input type="radio" name="heatview" value="pieces"> Piece Count</label></div><div class="legend-section"><h4>Legend</h4><div class="legend-item"><span class="legend-color" style="background:#0099FF"></span> <span>Downloads</span></div><div class="legend-item"><span class="legend-color" style="background:#00FF00"></span> <span>Uploads</span></div><div class="legend-item"><span class="legend-color" style="background:#CC00FF"></span> <span>Audits</span></div><div style="margin-top:8px"><div style="font-size:11px;margin-bottom:2px">Activity Heat:</div><div class="legend-gradient"></div><div style="font-size:10px;display:flex;justify-content:space-between"><span>Low</span> <span>High</span></div></div></div>`; container.addEventListener('change', e => { if (e.target.name === 'heatview') heatmap.setViewMode(e.target.value); }); window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => { const isDark = e.matches; container.style.backgroundColor = isDark ? '#1e1e1e' : 'white'; container.style.color = isDark ? '#e0e0e0' : '#333'; container.style.borderColor = isDark ? '#444' : '#ccc'; }); L.DomEvent.disableClickPropagation(container); L.DomEvent.disableScrollPropagation(container); return container; }
        });
        map.addControl(new HeatmapControl());

        // --- Constants & State ---
        const DOWNLOAD_COLOR = '#0ea5e9'; const UPLOAD_COLOR = '#22c55e';
        const PERFORMANCE_INTERVAL_MS = 2000;
        const MAX_PERF_POINTS = 150;
        let satelliteViewIsBySize = false; let lastSatelliteData = [];
        const performanceState = {
            view: 'rate', // rate, volume, pieces, concurrency
            range: '5m', // 5m, 30m, 1h, 6h, 24h
            agg: 'sum' // sum, avg
        };
        const TOGGLEABLE_CARDS = {
            'map-card': 'Live Traffic Heatmap',
            'stats-card': 'Overall Success Rates & Speed',
            'health-card': 'Node Health & History',
            'performance-card': 'Live Performance',
            'satellite-card': 'Traffic by Satellite',
            'analysis-card': 'Network & Error Analysis',
            'size-charts-card': 'Data Transfer Size Distribution',
            'hashstore-chart-card': 'Hashstore Compaction Trends',
            'hashstore-card': 'Hashstore Compaction Details'
        };
        let cardVisibilityState = {};
        const VISIBILITY_STORAGE_KEY = 'storj-pro-monitor-card-visibility';
        // This is the new primary data store for performance data, keyed by node name.
        // Each node's data is an object where keys are binned timestamps.
        let livePerformanceBins = {};
        let historicalPerformanceData = {};
        let currentNodeView = ['Aggregate'];
        let availableNodes = [];
        let performanceChartInstance = null;
        let chartUpdateTimer = null; // For debouncing live updates
        let hashstoreMasterData = []; // This holds the raw data from the server
        let hashstoreChartInstance = null;
        let hashstoreFilters = { satellite: 'all', store: 'all' };
        let hashstoreSort = { column: 'last_run_iso', direction: 'desc' };

        // --- Card Visibility & Layout ---
        function isCardVisible(cardId) {
            // Default to visible if the state hasn't been explicitly set to false
            return cardVisibilityState[cardId] !== false;
        }

        function initializeDisplayMenu() {
            const container = document.getElementById('display-menu-container');
            const btn = document.getElementById('display-menu-btn');
            const dropdown = document.getElementById('display-menu-dropdown');

            if (!container || !btn || !dropdown) return;

            let dropdownHTML = '<h5>Visible Cards</h5>';
            for (const cardId in TOGGLEABLE_CARDS) {
                dropdownHTML += `
                    <label>
                        <input type="checkbox" data-card-id="${cardId}">
                        <span>${TOGGLEABLE_CARDS[cardId]}</span>
                    </label>
                `;
            }
            dropdown.innerHTML = dropdownHTML;


            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('visible');
                btn.classList.toggle('active');
            });

            dropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const cardId = e.target.dataset.cardId;
                    cardVisibilityState[cardId] = e.target.checked;
                    localStorage.setItem(VISIBILITY_STORAGE_KEY, JSON.stringify(cardVisibilityState));
                    applyCardLayout();
                }
            });

            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    dropdown.classList.remove('visible');
                    btn.classList.remove('active');
                }
            });

            loadCardVisibility();
        }

        function loadCardVisibility() {
            const savedState = localStorage.getItem(VISIBILITY_STORAGE_KEY);
            let state = {};
            if (savedState) {
                try { state = JSON.parse(savedState); } catch (e) { console.error("Could not parse visibility state.", e); }
            }

            const defaultState = Object.keys(TOGGLEABLE_CARDS).reduce((acc, key) => ({...acc, [key]: true }), {});
            cardVisibilityState = { ...defaultState, ...state };

            applyCardLayout();
        }

        function applyCardLayout() {
            // First, update checkboxes and toggle visibility class
            for (const cardId in cardVisibilityState) {
                const cardElement = document.getElementById(cardId);
                const checkbox = document.querySelector(`#display-menu-dropdown input[data-card-id="${cardId}"]`);

                if (cardElement && checkbox) {
                    const isVisible = cardVisibilityState[cardId];
                    cardElement.classList.toggle('is-hidden', !isVisible);
                    checkbox.checked = isVisible;

                    // Pause/resume the heatmap based on visibility
                    if (cardId === 'map-card') {
                        if (isVisible) {
                            heatmap.resume();
                        } else {
                            heatmap.pause();
                        }
                    }
                }
            }
            // Then, reflow the grid
            reflowGrid();
        }

        function reflowGrid() {
            let currentRow = 2;
            const isVisible = (id) => cardVisibilityState[id];
            const setStyle = (id, col, row) => {
                const el = document.getElementById(id);
                if (el) { Object.assign(el.style, { gridColumn: col, gridRow: row }); }
            };

            // Row 1: Map and Stats/Health
            const mapVisible = isVisible('map-card');
            const statsVisible = isVisible('stats-card');
            const healthVisible = isVisible('health-card');

            if (mapVisible) {
                setStyle('map-card', '1 / 8', '2 / 4');
                if (statsVisible) setStyle('stats-card', '8 / 13', '2 / 3');
                if (healthVisible) setStyle('health-card', '8 / 13', '3 / 4');
                currentRow = 4;
            } else {
                if (statsVisible && healthVisible) {
                    setStyle('stats-card', '1 / 7', '2 / 3');
                    setStyle('health-card', '7 / 13', '2 / 3');
                    currentRow = 3;
                } else if (statsVisible) {
                    setStyle('stats-card', '1 / -1', '2 / 3');
                    currentRow = 3;
                } else if (healthVisible) {
                    setStyle('health-card', '1 / -1', '2 / 3');
                    currentRow = 3;
                }
            }

            // Row 2: Performance and Satellite
            const perfVisible = isVisible('performance-card');
            const satVisible = isVisible('satellite-card');
            if (perfVisible && satVisible) {
                setStyle('performance-card', '1 / 7', `${currentRow} / ${currentRow + 1}`);
                setStyle('satellite-card', '7 / 13', `${currentRow} / ${currentRow + 1}`);
                currentRow++;
            } else if (perfVisible) {
                setStyle('performance-card', '1 / -1', `${currentRow} / ${currentRow + 1}`);
                currentRow++;
            } else if (satVisible) {
                setStyle('satellite-card', '1 / -1', `${currentRow} / ${currentRow + 1}`);
                currentRow++;
            }

            // Subsequent full-width cards
            ['analysis-card', 'size-charts-card', 'hashstore-chart-card', 'hashstore-card'].forEach(cardId => {
                if (isVisible(cardId)) {
                    setStyle(cardId, '1 / -1', `${currentRow} / ${currentRow + 1}`);
                    currentRow++;
                }
            });

            // If map was shown, invalidate its size to fix rendering
            if (mapVisible) {
                setTimeout(() => map.invalidateSize(), 150);
            }
        }


        // --- Helper Functions ---
        function formatBytes(bytes, decimals = 2) { if (!bytes || bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
        function getRateClass(rate) { if (rate > 99.5) return 'rate-good'; if (rate > 95) return 'rate-ok'; return 'rate-bad'; }
        const SATELLITE_NAMES = { '121RTSDpyNZVcEU84Ticf2L1ntiuUimbWgfATz21tuvgk3vzoA6': 'ap1', '12EayRS2V1kEsWESU9QMRseFhdxYxKicsiFmxrsLZHeLUtdps3S': 'us1', '12L9ZFwhzVpuEKMUNUqkaTLGzwY9G24tbiigLiXpmZWKwmcNDDs': 'eu1', '1wFTAgs9DP5RSnCqKV1eLf6N9wtk4EAtmN5DpSxcs8EjT69tGE': 'saltlake' };

        // --- Chart Initialization ---
        function createHashstoreChart() {
            if (hashstoreChartInstance) {
                hashstoreChartInstance.destroy();
            }
            const ctx = document.getElementById('hashstoreChart').getContext('2d');
            hashstoreChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Compaction Date' }
                        },
                        'y-data': {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Data Size' },
                            stacked: true,
                            ticks: {
                                callback: function(value) { return formatBytes(value); }
                            }
                        },
                        'y-duration': {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Duration (s)' },
                            grid: { drawOnChartArea: false } // only draw grid for left axis
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                beforeBody: function(tooltipItems) {
                                    const item = tooltipItems[0];
                                    if (!item) return [];

                                    const chart = item.chart;
                                    const sortedData = chart.sortedData;
                                    const dataPoint = sortedData && sortedData[item.dataIndex];

                                    if (!dataPoint) return [];

                                    const satelliteName = SATELLITE_NAMES[dataPoint.satellite] || dataPoint.satellite.substring(0, 12);

                                    return [
                                        `Node: ${dataPoint.node_name}`,
                                        `Satellite: ${satelliteName}`,
                                        `Store: ${dataPoint.store}`,
                                        '' // Spacer
                                    ];
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'y-data') {
                                            label += formatBytes(context.parsed.y);
                                        } else {
                                            label += `${context.parsed.y.toFixed(1)}s`;
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPerformanceChart() {
            if (performanceChartInstance) {
                performanceChartInstance.destroy();
            }
            const ctx = document.getElementById('performanceChart').getContext('2d');
            const isLiveView = performanceState.range === '5m';
            const chartType = isLiveView ? 'line' : 'bar';
            const options = { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { tooltipFormat: 'PP pp' } }, y: { beginAtZero: true, title: { display: true } } } };
            if (isLiveView) {
                options.scales.x.time.unit = 'minute';
            } else {
                options.scales.x.stacked = true;
                options.scales.y.stacked = true;
                options.plugins = {
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                try {
                                    if (!context || context.length === 0) return '';
                                    const d = new Date(context[0].parsed.x);
                                    const dataIndex = context[0].dataIndex;
                                    const dataset = context[0].chart.data.datasets[context[0].datasetIndex];
                                    let intervalMs = 0;
                                    if (dataIndex + 1 < dataset.data.length) {
                                        const nextPointX = dataset.data[dataIndex + 1].x;
                                        intervalMs = new Date(nextPointX).getTime() - d.getTime();
                                    } else if (dataIndex > 0) {
                                        const prevPointX = dataset.data[dataIndex - 1].x;
                                        intervalMs = d.getTime() - new Date(prevPointX).getTime();
                                    }
                                    if (intervalMs > 0) {
                                        const next_d = new Date(d.getTime() + intervalMs);
                                        const timeFormat = { hour: '2-digit', minute:'2-digit', second: '2-digit' };
                                        return `Interval: ${d.toLocaleTimeString([], timeFormat)} - ${next_d.toLocaleTimeString([], timeFormat)}`;
                                    }
                                    return d.toLocaleString();
                                } catch (e) {
                                    console.error("Tooltip title error:", e);
                                    return "Error";
                                }
                            }
                        }
                    }
                };
            }
            performanceChartInstance = new Chart(ctx, { type: chartType, data: { datasets: [] }, options: options });
        }
        const satelliteChart = new Chart(document.getElementById('satelliteChart').getContext('2d'), { type: 'bar', data: { labels: [], datasets: [{ label: 'Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Downloads/Audits', data: [], backgroundColor: DOWNLOAD_COLOR }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { stacked: true, title: { display: true, text: 'Pieces' } }, y: { stacked: true } }, plugins: { tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.x !== null) { if (satelliteViewIsBySize) { label += formatBytes(context.parsed.x); } else { label += new Intl.NumberFormat().format(context.parsed.x); } } return label; }, footer: function(tooltipItems) { const context = tooltipItems[0]; if (lastSatelliteData.length === 0 || context.dataIndex >= lastSatelliteData.length) return ''; const satData = lastSatelliteData[context.dataIndex]; const lines = []; const totalDl = satData.downloads + satData.audits; if (totalDl > 0) lines.push(`DL Success: ${(satData.dl_success/totalDl*100).toFixed(2)}% (${satData.dl_success}/${totalDl})`); const totalUl = satData.uploads; if (totalUl > 0) lines.push(`UL Success: ${(satData.ul_success/totalUl*100).toFixed(2)}% (${satData.ul_success}/${totalUl})`); return lines; } } } } } });
        const sizeBarChart = new Chart(document.getElementById('sizeBarChart').getContext('2d'), { type: 'bar', data: { labels: [], datasets: [{ label: 'Successful Downloads', data: [], backgroundColor: DOWNLOAD_COLOR }, { label: 'Successful Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Failed Downloads', data: [], backgroundColor: '#ef4444' }, { label: 'Failed Uploads', data: [], backgroundColor: '#f97316' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Size Bucket' }, stacked: true }, y: { title: { display: true, text: 'Count' }, stacked: true } }, plugins: { legend: { position: 'top' }, tooltip: { callbacks: { footer: function(tooltipItems) { const item = tooltipItems[0]; const datasetLabels = ['successful downloads', 'successful uploads', 'failed downloads', 'failed uploads']; return `${item.parsed.y} ${datasetLabels[item.datasetIndex]} in this size range`; } } } } } });
        sizeBarChart.currentViewMode = 'counts'; // Add state to the chart instance
        let sizeChartViewMode = 'counts'; // counts, percentages, rates

        // --- UI Update Functions ---
        function updateAllVisuals(data) {
            if (isCardVisible('stats-card')) updateOverallStats(data.overall);
            if (isCardVisible('satellite-card')) updateSatelliteChart(data.satellites);
            if (isCardVisible('size-charts-card')) updateSizeBarChart(data.transfer_sizes);
            updateTitles(data.first_event_iso, data.last_event_iso);
            if (isCardVisible('health-card')) updateHistoricalTable(data.historical_stats);
            if (isCardVisible('analysis-card')) updateAnalysisTables(data);
        }
        function updateOverallStats(stats) { if (!stats || Object.keys(stats).length === 0) return; const totalDownloads = stats.dl_success + stats.dl_fail; const totalUploads = stats.ul_success + stats.ul_fail; const totalAudits = stats.audit_success + stats.audit_fail; const dlRate = totalDownloads > 0 ? (stats.dl_success / totalDownloads * 100).toFixed(2) : '100.00'; const ulRate = totalUploads > 0 ? (stats.ul_success / totalUploads * 100).toFixed(2) : '100.00'; const auditRate = totalAudits > 0 ? (stats.audit_success / totalAudits * 100).toFixed(2) : '100.00'; document.getElementById('dl-rate').textContent = `${dlRate}%`; document.getElementById('dl-rate').className = `stat-value ${getRateClass(parseFloat(dlRate))}`; document.getElementById('dl-success').textContent = stats.dl_success; document.getElementById('dl-total').textContent = totalDownloads; document.getElementById('ul-rate').textContent = `${ulRate}%`; document.getElementById('ul-rate').className = `stat-value ${getRateClass(parseFloat(ulRate))}`; document.getElementById('ul-success').textContent = stats.ul_success; document.getElementById('ul-total').textContent = totalUploads; document.getElementById('dl-speed').textContent = `${(stats.avg_egress_mbps||0).toFixed(2)} Mbps`; document.getElementById('ul-speed').textContent = `${(stats.avg_ingress_mbps||0).toFixed(2)} Mbps`; document.getElementById('audit-rate').textContent = `${auditRate}%`; document.getElementById('audit-rate').className = `stat-value ${getRateClass(parseFloat(auditRate))}`; document.getElementById('audit-success').textContent = stats.audit_success; document.getElementById('audit-total').textContent = totalAudits; }
        function updateSatelliteChart(satStats) {
            if (!satStats) return;
            lastSatelliteData = satStats;
            const xscale = satelliteChart.options.scales.x;
            satelliteChart.data.labels = satStats.map(s => SATELLITE_NAMES[s.satellite_id] || s.satellite_id.substring(0, 12));
            if (satelliteViewIsBySize) {
                xscale.title.text = 'Data Transferred';
                if (!xscale.ticks) xscale.ticks = {};
                xscale.ticks.callback = (value) => formatBytes(value, 1);
                satelliteChart.data.datasets[0].data = satStats.map(s => s.total_upload_size);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.total_download_size);
                satelliteChart.data.datasets[0].label = 'Upload Size';
                satelliteChart.data.datasets[1].label = 'Download Size';
            } else {
                xscale.title.text = 'Pieces';
                if (xscale.ticks) {
                    delete xscale.ticks.callback;
                }
                satelliteChart.data.datasets[0].data = satStats.map(s => s.uploads);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.downloads + s.audits);
                satelliteChart.data.datasets[0].label = 'Uploads';
                satelliteChart.data.datasets[1].label = 'Downloads/Audits';
            }
            satelliteChart.update();
        }
        let lastTransferSizes = [];
        function updateSizeBarChart(transferSizes) {
            if (!transferSizes) return;
            lastTransferSizes = transferSizes;
            const allBuckets = ["< 1 KB", "1-4 KB", "4-16 KB", "16-64 KB", "64-256 KB", "256 KB - 1 MB", "> 1 MB"];
            sizeBarChart.data.labels = allBuckets;

            const processedData = allBuckets.map(bucketName => {
                const bucket = transferSizes.find(b => b.bucket === bucketName) || {};
                return {
                    dl_s: bucket.downloads_success || 0,
                    dl_f: bucket.downloads_failed || 0,
                    ul_s: bucket.uploads_success || 0,
                    ul_f: bucket.uploads_failed || 0,
                };
            });

            const viewChanged = (sizeChartViewMode !== sizeBarChart.currentViewMode);

            if (viewChanged) {
                // --- FULL RECONFIGURATION (only on view mode change) ---
                switch (sizeChartViewMode) {
                    case 'counts':
                        Object.assign(sizeBarChart.options.scales.x, { stacked: true });
                        Object.assign(sizeBarChart.options.scales.y, { stacked: true, title: { text: 'Count' }, min: undefined, max: undefined });
                        sizeBarChart.data.datasets = [
                            { label: 'Successful Downloads', data: [], backgroundColor: DOWNLOAD_COLOR }, { label: 'Successful Uploads', data: [], backgroundColor: UPLOAD_COLOR },
                            { label: 'Failed Downloads', data: [], backgroundColor: '#ef4444' }, { label: 'Failed Uploads', data: [], backgroundColor: '#f97316' }
                        ];
                        sizeBarChart.options.plugins.tooltip.callbacks.footer = (items) => `${items[0].parsed.y} transfers`;
                        break;
                    case 'percentages':
                        Object.assign(sizeBarChart.options.scales.x, { stacked: true });
                        Object.assign(sizeBarChart.options.scales.y, { stacked: true, title: { text: 'Percentage (%)' }, min: 0, max: 100 });
                        sizeBarChart.data.datasets = [
                             { label: 'Successful Downloads', data: [], backgroundColor: DOWNLOAD_COLOR }, { label: 'Successful Uploads', data: [], backgroundColor: UPLOAD_COLOR },
                             { label: 'Failed Downloads', data: [], backgroundColor: '#ef4444' }, { label: 'Failed Uploads', data: [], backgroundColor: '#f97316' }
                        ];
                        sizeBarChart.options.plugins.tooltip.callbacks.footer = (items) => {
                             const item = items[0]; const total = processedData.reduce((sum, d) => sum + d.dl_s + d.dl_f + d.ul_s + d.ul_f, 0);
                             const bucketData = processedData[item.dataIndex];
                             const counts = [bucketData.dl_s, bucketData.ul_s, bucketData.dl_f, bucketData.ul_f];
                             return `${item.parsed.y.toFixed(2)}% (${counts[item.datasetIndex]} transfers)`;
                        };
                        break;
                    case 'rates':
                        Object.assign(sizeBarChart.options.scales.x, { stacked: false });
                        Object.assign(sizeBarChart.options.scales.y, { stacked: false, title: { text: 'Success Rate (%)' }, max: 100 });
                        sizeBarChart.data.datasets = [
                            { label: 'Download Success Rate', data: [], backgroundColor: DOWNLOAD_COLOR }, { label: 'Upload Success Rate', data: [], backgroundColor: UPLOAD_COLOR }
                        ];
                        sizeBarChart.options.plugins.tooltip.callbacks.footer = (items) => {
                            const item = items[0]; const data = processedData[item.dataIndex];
                            return item.datasetIndex === 0 ? `Raw: ${data.dl_s}/${data.dl_s + data.dl_f}` : `Raw: ${data.ul_s}/${data.ul_s + data.ul_f}`;
                        };
                        break;
                }
                sizeBarChart.currentViewMode = sizeChartViewMode;
            }

            // --- ALWAYS UPDATE DATA & DYNAMIC OPTIONS ---
            switch (sizeChartViewMode) {
                case 'counts':
                    sizeBarChart.data.datasets[0].data = processedData.map(d => d.dl_s); sizeBarChart.data.datasets[1].data = processedData.map(d => d.ul_s);
                    sizeBarChart.data.datasets[2].data = processedData.map(d => d.dl_f); sizeBarChart.data.datasets[3].data = processedData.map(d => d.ul_f);
                    break;
                case 'percentages':
                    const total = processedData.reduce((sum, d) => sum + d.dl_s + d.dl_f + d.ul_s + d.ul_f, 0);
                    if (total > 0) {
                        sizeBarChart.data.datasets[0].data = processedData.map(d => d.dl_s / total * 100); sizeBarChart.data.datasets[1].data = processedData.map(d => d.ul_s / total * 100);
                        sizeBarChart.data.datasets[2].data = processedData.map(d => d.dl_f / total * 100); sizeBarChart.data.datasets[3].data = processedData.map(d => d.ul_f / total * 100);
                    }
                    break;
                case 'rates':
                    const dlRates = processedData.map(d => { const total = d.dl_s + d.dl_f; return total > 0 ? (d.dl_s / total * 100) : 0; });
                    const ulRates = processedData.map(d => { const total = d.ul_s + d.ul_f; return total > 0 ? (d.ul_s / total * 100) : 0; });
                    const minRate = Math.min(...dlRates.filter(r => r > 0), ...ulRates.filter(r => r > 0), 95);
                    sizeBarChart.options.scales.y.min = Math.floor(Math.min(95, minRate < 95 ? minRate - 1 : 95));
                    sizeBarChart.data.datasets[0].data = dlRates; sizeBarChart.data.datasets[1].data = ulRates;
                    break;
            }
            sizeBarChart.update();
        }
        function updateTitles(firstIso, lastIso) {
            const formatTime = date => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let timeWindowStr = "(Last 60 Mins)";
            if (firstIso && lastIso) {
                timeWindowStr = `(${formatTime(new Date(firstIso))} - ${formatTime(new Date(lastIso))})`;
            }
            const getFriendlyViewName = () => {
                if (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate') return 'Aggregate';
                if (currentNodeView.length === 1) return currentNodeView[0];
                if (currentNodeView.length > 3) return `${currentNodeView.length} nodes`;
                return currentNodeView.join(', ');
            };
            const viewName = getFriendlyViewName();
            const viewNameForTitle = viewName === 'Aggregate' ? '' : ` (${viewName})`;

            if (isCardVisible('stats-card')) {
                document.getElementById('stats-title').textContent = `Overall Success Rates & Speed${viewNameForTitle} ${timeWindowStr}`;
                const isAggregateView = currentNodeView.length > 1 || (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate');
                document.getElementById('dl-speed-label').textContent = isAggregateView ? 'Total Download Speed' : 'Download Speed';
                document.getElementById('ul-speed-label').textContent = isAggregateView ? 'Total Upload Speed' : 'Upload Speed';
            }
             if (isCardVisible('satellite-card')) {
                document.getElementById('satellite-title').textContent = `Traffic by Satellite${viewNameForTitle} ${timeWindowStr}`;
            }
            if (isCardVisible('size-charts-card')) {
                document.getElementById('size-chart-title').textContent = `Data Transfer Size Distribution${viewNameForTitle} ${timeWindowStr}`;
            }
            if (isCardVisible('hashstore-chart-card')) {
                document.getElementById('hashstore-chart-title').textContent = `Hashstore Compaction Trends${viewNameForTitle}`;
            }
            if (isCardVisible('hashstore-card')) {
                document.getElementById('hashstore-title').textContent = `Hashstore Compaction Details${viewNameForTitle}`;
            }
        }
        function updateHistoricalTable(history) { const tbody = document.getElementById('history-body'); tbody.innerHTML = ''; if (!history || history.length === 0) { tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No historical data yet.</td></tr>'; return; } for (const hour of history) { const totalDl = hour.dl_success + hour.dl_fail, dlRate = totalDl > 0 ? (hour.dl_success / totalDl * 100) : 100; const totalUl = hour.ul_success + hour.ul_fail, ulRate = totalUl > 0 ? (hour.ul_success / totalUl * 100) : 100; const totalAudit = hour.audit_success + hour.audit_fail, auditRate = totalAudit > 0 ? (hour.audit_success / totalAudit * 100) : 100; const dlSpeed = hour.dl_mbps !== undefined ? hour.dl_mbps.toFixed(2) : '...'; const ulSpeed = hour.ul_mbps !== undefined ? hour.ul_mbps.toFixed(2) : '...'; const row = tbody.insertRow(); row.innerHTML = `<td>${new Date(hour.hour_timestamp).toLocaleTimeString([],{hour:'numeric'})}</td><td class="numeric ${getRateClass(dlRate)}">${dlRate.toFixed(2)}%</td><td class="numeric ${getRateClass(ulRate)}">${ulRate.toFixed(2)}%</td><td class="numeric ${getRateClass(auditRate)}">${auditRate.toFixed(2)}%</td><td class="numeric">${dlSpeed} Mbps</td><td class="numeric">${ulSpeed} Mbps</td>`; } }
        function updateAnalysisTables(data) { const errorBody = document.getElementById('error-body'); errorBody.innerHTML = ''; if (data.error_categories && data.error_categories.length > 0) { data.error_categories.forEach(e => { errorBody.innerHTML += `<tr><td class="reason-cell">${e.reason}</td><td class="numeric">${e.count}</td></tr>`; }); } else { errorBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No errors in this time window.</td></tr>'; } const piecesBody = document.getElementById('pieces-body'); piecesBody.innerHTML = ''; if (data.top_pieces && data.top_pieces.length > 0) { data.top_pieces.forEach(p => { piecesBody.innerHTML += `<tr><td class="piece-id">${p.id.substring(0,25)}...</td><td class="numeric">${p.count}</td><td class="numeric">${formatBytes(p.size)}</td></tr>`; }); } else { piecesBody.innerHTML = '<tr><td colspan="3" style="text-align: center;">No data in this time window.</td></tr>'; } const countriesDlBody = document.getElementById('countries-dl-body'); countriesDlBody.innerHTML = ''; if (data.top_countries_dl && data.top_countries_dl.length > 0) { data.top_countries_dl.forEach(c => countriesDlBody.innerHTML += `<tr><td>${c.country}</td><td class="numeric">${formatBytes(c.size)}</td></tr>`); } else { countriesDlBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No data in this time window.</td></tr>'; } const countriesUlBody = document.getElementById('countries-ul-body'); countriesUlBody.innerHTML = ''; if (data.top_countries_ul && data.top_countries_ul.length > 0) { data.top_countries_ul.forEach(c => countriesUlBody.innerHTML += `<tr><td>${c.country}</td><td class="numeric">${formatBytes(c.size)}</td></tr>`); } else { countriesUlBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No data in this time window.</td></tr>'; } }

        // --- START: Hashstore Panel Interactive Logic ---
        function updateHashstorePanel(stats) {
            hashstoreMasterData = stats || [];
            // Filters are only populated once, when the first batch of data arrives.
            if (document.getElementById('hashstore-filters').innerHTML.trim() === "<!-- JS populates this -->") {
                populateHashstoreFilters();
            }
            renderHashstoreView();
        }

        function populateHashstoreFilters() {
            const filtersContainer = document.getElementById('hashstore-filters');
            if (!filtersContainer) return;

            // Use a Set to get unique values, then sort them. Populate from ALL possible data.
            const satellites = [...new Set(hashstoreMasterData.map(item => SATELLITE_NAMES[item.satellite] || item.satellite))].sort();
            const stores = [...new Set(hashstoreMasterData.map(item => item.store))].sort();

            let filtersHTML = `
                <label>Satellite: <select data-filter="satellite">
                    <option value="all">All</option>
                    ${satellites.map(s => `<option value="${s}">${s}</option>`).join('')}
                </select></label>
                <label>Store: <select data-filter="store">
                    <option value="all">All</option>
                    ${stores.map(s => `<option value="${s}">${s}</option>`).join('')}
                </select></label>`;

            filtersContainer.innerHTML = filtersHTML;
            filtersContainer.querySelectorAll('select').forEach(sel => {
                sel.addEventListener('change', (e) => {
                    hashstoreFilters[e.target.dataset.filter] = e.target.value;
                    requestHashstoreData();
                });
            });
        }

        function updateHashstoreChart(data) {
            if (!hashstoreChartInstance) createHashstoreChart();

            // Data for chart should be sorted ascending by date
            const sortedData = [...data].sort((a, b) => new Date(a.last_run_iso) - new Date(b.last_run_iso));

            // Store this for tooltip access
            hashstoreChartInstance.sortedData = sortedData;

            const labels = sortedData.map(item => new Date(item.last_run_iso).toLocaleString());
            const durationData = sortedData.map(item => item.duration);
            const reclaimedData = sortedData.map(item => item.data_reclaimed_bytes);
            const rewrittenData = sortedData.map(item => item.data_rewritten_bytes);

            hashstoreChartInstance.data.labels = labels;
            hashstoreChartInstance.data.datasets = [
                {
                    type: 'line',
                    label: 'Duration',
                    data: durationData,
                    borderColor: '#f59e0b', // rate-ok color
                    backgroundColor: '#f59e0b',
                    yAxisID: 'y-duration',
                    tension: 0.2,
                },
                {
                    type: 'bar',
                    label: 'Data Reclaimed',
                    data: reclaimedData,
                    backgroundColor: UPLOAD_COLOR,
                    yAxisID: 'y-data',
                    stack: 'data',
                },
                {
                    type: 'bar',
                    label: 'Data Rewritten',
                    data: rewrittenData,
                    backgroundColor: DOWNLOAD_COLOR,
                    yAxisID: 'y-data',
                    stack: 'data',
                }
            ];
            hashstoreChartInstance.update('none');
        }

        function renderHashstoreView() {
            // 1. Update Chart with date-sorted data
            if (isCardVisible('hashstore-chart-card')) {
                updateHashstoreChart(hashstoreMasterData);
            }

            // 2. Pre-process data for table: create a copy and add derived metrics
            let tableData = hashstoreMasterData.map(item => {
                const newItem = {...item}; // Create a copy
                newItem.reclaim_efficiency = newItem.data_rewritten_bytes > 0 ? newItem.data_reclaimed_bytes / newItem.data_rewritten_bytes : Infinity;
                newItem.throughput = newItem.duration > 0.01 ? (newItem.data_reclaimed_bytes + newItem.data_rewritten_bytes) / newItem.duration : 0;
                return newItem;
            });

            // 3. Sort table data
            const { column, direction } = hashstoreSort;
            tableData.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (typeof valA === 'number' && typeof valB === 'number') {
                    if (column === 'reclaim_efficiency') {
                        if (valA === Infinity) valA = Number.MAX_SAFE_INTEGER;
                        if (valB === Infinity) valB = Number.MAX_SAFE_INTEGER;
                    }
                    return direction === 'asc' ? valA - valB : valB - valA;
                }

                const strA = String(valA || '');
                const strB = String(valB || '');
                return direction === 'asc' ? strA.localeCompare(strB) : strB.localeCompare(strA);
            });

            // 4. Render table
            if (isCardVisible('hashstore-card')) {
                renderHashstoreTable(tableData);
            }
        }

        function renderHashstoreTable(data) {
            const tbody = document.getElementById('hashstore-body');
            const tfoot = document.getElementById('hashstore-foot');
            const headers = document.querySelectorAll('#hashstore-card th[data-column]');
            tbody.innerHTML = '';
            tfoot.innerHTML = '';

            const showNodeColumn = currentNodeView[0] === 'Aggregate' || currentNodeView.length > 1;
            document.querySelector('#hashstore-card th[data-column="node_name"]').style.display = showNodeColumn ? '' : 'none'

            if (!data || data.length === 0) {
                const colspan = showNodeColumn ? 11 : 10;
                tbody.innerHTML = `<tr><td colspan="${colspan}" style="text-align: center;">No matching compaction events found.</td></tr>`;
                return;
            }

            let totalReclaimed = 0, totalRewritten = 0, totalDuration = 0, totalBytesProcessed = 0;
            let totalLoad = 0, totalTrash = 0;

            for (const item of data) {
                totalReclaimed += item.data_reclaimed_bytes;
                totalRewritten += item.data_rewritten_bytes;
                const bytesProcessed = item.data_reclaimed_bytes + item.data_rewritten_bytes;
                totalBytesProcessed += bytesProcessed;
                if (bytesProcessed > 0) {
                    totalDuration += item.duration * bytesProcessed; // For weighted average
                    totalLoad += item.table_load * bytesProcessed;
                    totalTrash += item.trash_percent * bytesProcessed;
                }

                const row = tbody.insertRow();
                let cellIndex = 0;

                row.insertCell(cellIndex++).textContent = item.node_name;
                row.insertCell(cellIndex++).textContent = SATELLITE_NAMES[item.satellite] || item.satellite.substring(0,12);
                row.insertCell(cellIndex++).textContent = item.store;

                const lastRunCell = row.insertCell(cellIndex++);
                lastRunCell.textContent = new Date(item.last_run_iso).toLocaleTimeString();

                const durationCell = row.insertCell(cellIndex++);
                durationCell.className = 'numeric';
                durationCell.textContent = `${item.duration.toFixed(1)}s`;
                if (item.duration > 180) durationCell.classList.add('rate-bad'); else if (item.duration > 60) durationCell.classList.add('rate-ok');

                const reclaimedCell = row.insertCell(cellIndex++);
                reclaimedCell.className = 'numeric';
                reclaimedCell.textContent = formatBytes(item.data_reclaimed_bytes);

                const rewrittenCell = row.insertCell(cellIndex++);
                rewrittenCell.className = 'numeric';
                rewrittenCell.textContent = formatBytes(item.data_rewritten_bytes);

                const efficiencyCell = row.insertCell(cellIndex++);
                efficiencyCell.className = 'numeric';
                if (item.reclaim_efficiency === Infinity) efficiencyCell.textContent = 'Pure Reclaim';
                else if (item.data_rewritten_bytes > 0) efficiencyCell.textContent = `${item.reclaim_efficiency.toFixed(1)}x`;
                else efficiencyCell.textContent = 'N/A';
                if (item.reclaim_efficiency > 10) efficiencyCell.classList.add('rate-good');

                const throughputCell = row.insertCell(cellIndex++);
                throughputCell.className = 'numeric';
                throughputCell.textContent = formatBytes(item.throughput, 2) + '/s';
                if (item.throughput > 50 * 1024 * 1024) throughputCell.classList.add('rate-good');

                const loadCell = row.insertCell(cellIndex++);
                loadCell.className = 'numeric';
                loadCell.textContent = `${item.table_load.toFixed(2)}%`;
                if (item.table_load > 60) loadCell.classList.add('rate-bad'); else if (item.table_load > 40) loadCell.classList.add('rate-ok');

                const trashCell = row.insertCell(cellIndex++);
                trashCell.className = 'numeric';
                trashCell.textContent = `${item.trash_percent.toFixed(2)}%`;

                // Hide node cell if not in aggregate view
                row.cells[0].style.display = showNodeColumn ? '' : 'none';
            }

            // Render summary footer
            const avgDuration = totalBytesProcessed > 0 ? totalDuration / totalBytesProcessed : 0;
            const avgLoad = totalBytesProcessed > 0 ? totalLoad / totalBytesProcessed : 0;
            const avgTrash = totalBytesProcessed > 0 ? totalTrash / totalBytesProcessed : 0;
            const avgEfficiency = totalRewritten > 0 ? totalReclaimed / totalRewritten : Infinity;
            const avgThroughput = data.length > 0 ? data.reduce((sum, item) => sum + item.throughput, 0) / data.length : 0;

            const footRow = tfoot.insertRow();
            const firstCell = footRow.insertCell();
            firstCell.colSpan = showNodeColumn ? 4 : 3;
            firstCell.textContent = `Totals / Weighted Averages (${data.length} entr${data.length > 1 ? 'ies' : 'y'})`;
            firstCell.style.fontWeight = 'bold';

            const addNumericFootCell = (text) => {
                const cell = footRow.insertCell();
                cell.className = 'numeric';
                cell.textContent = text;
            };

            addNumericFootCell(`${avgDuration.toFixed(1)}s`);
            addNumericFootCell(formatBytes(totalReclaimed));
            addNumericFootCell(formatBytes(totalRewritten));
            const efficiencyVal = (avgEfficiency === Infinity) ? 'Pure Reclaim' : (totalRewritten > 0 ? `${avgEfficiency.toFixed(1)}x` : 'N/A');
            addNumericFootCell(efficiencyVal);
            addNumericFootCell(formatBytes(avgThroughput) + '/s');
            addNumericFootCell(`${avgLoad.toFixed(2)}%`);
            addNumericFootCell(`${avgTrash.toFixed(2)}%`);

            // Update sort indicators
            headers.forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.column === hashstoreSort.column) {
                    th.classList.add(hashstoreSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        document.querySelector('#hashstore-card table thead').addEventListener('click', e => {
            const header = e.target.closest('th');
            if (!header || !header.dataset.column) return;
            const column = header.dataset.column;
            if (hashstoreSort.column === column) {
                hashstoreSort.direction = hashstoreSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                hashstoreSort.column = column;
                // Sensible default sort directions
                const textColumns = ['node_name', 'satellite', 'store'];
                hashstoreSort.direction = textColumns.includes(column) ? 'asc' : 'desc';
            }
            renderHashstoreView();
        });
        // --- END: Hashstore Panel Interactive Logic ---

        function dataTemplate() {
            return { rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[]] };
        }

        function requestHashstoreData() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                let filters_to_send = { ...hashstoreFilters }; // copy to avoid mutation
                if (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate') {
                    filters_to_send.node_name = 'all';
                } else {
                    filters_to_send.node_name = currentNodeView; // Send the array of node names
                }
                ws.send(JSON.stringify({ type: 'get_hashstore_stats', filters: filters_to_send }));
            }
        }

        // --- Event Listeners ---
        document.getElementById('toggle-satellite-view').addEventListener('click', function(e) { e.preventDefault(); satelliteViewIsBySize = !satelliteViewIsBySize; this.textContent = satelliteViewIsBySize ? 'Show by Pieces' : 'Show by Size'; if(isCardVisible('satellite-card')) updateSatelliteChart(lastSatelliteData); });
        document.getElementById('size-view-toggles').addEventListener('click', function(e) { e.preventDefault(); const target = e.target; if (target.tagName === 'A' && !target.classList.contains('active')) { sizeChartViewMode = target.getAttribute('data-view'); document.querySelectorAll('#size-view-toggles .toggle-link').forEach(el => el.classList.remove('active')); target.classList.add('active'); if(isCardVisible('size-charts-card')) updateSizeBarChart(lastTransferSizes); } });
        document.getElementById('performance-toggles').addEventListener('click', function(e) { e.preventDefault(); if (e.target.tagName === 'A') { performanceState.view = e.target.getAttribute('data-view'); document.querySelectorAll('#performance-toggles .toggle-link').forEach(el => el.classList.remove('active')); e.target.classList.add('active'); updatePerformanceChart(); } });
        document.getElementById('time-range-toggles').addEventListener('click', function(e) { e.preventDefault(); const newRange = e.target.getAttribute('data-range'); if (newRange === performanceState.range) return; performanceState.range = newRange; document.querySelectorAll('#time-range-toggles .toggle-link').forEach(el => el.classList.remove('active')); e.target.classList.add('active'); createPerformanceChart(); if (newRange === '5m') { updatePerformanceChart(); } else { const hours = { '30m': 0.5, '1h': 1, '6h': 6, '24h': 24 }[newRange]; if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: 'get_aggregated_performance', view: currentNodeView, hours: hours })); } } });
        document.getElementById('aggregation-toggles').addEventListener('click', function(e) { e.preventDefault(); if (e.target.tagName === 'A') { performanceState.agg = e.target.getAttribute('data-agg'); document.querySelectorAll('#aggregation-toggles .toggle-link').forEach(el => el.classList.remove('active')); e.target.classList.add('active'); updatePerformanceChart(); } });
        function renderNodeSelector() {
            const selector = document.getElementById('node-selector');
            selector.innerHTML = '';
            const aggregateLink = document.createElement('a');
            aggregateLink.href = '#';
            aggregateLink.className = 'node-link';
            aggregateLink.textContent = 'Aggregate';
            aggregateLink.setAttribute('data-view', 'Aggregate');
            if (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate') {
                aggregateLink.classList.add('active');
            }
            selector.appendChild(aggregateLink);

            availableNodes.forEach(name => {
                const link = document.createElement('a');
                link.href = '#';
                link.className = 'node-link';
                link.textContent = name;
                link.setAttribute('data-view', name);
                if (currentNodeView.includes(name)) {
                    link.classList.add('active');
                }
                selector.appendChild(link);
            });
        }
        document.getElementById('node-selector').addEventListener('click', function(e) {
            e.preventDefault();
            if (!e.target.hasAttribute('data-view')) return;
            const clickedView = e.target.getAttribute('data-view');
            const isAggregate = clickedView === 'Aggregate';
            if (isAggregate) { currentNodeView = ['Aggregate']; } else { if (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate') { currentNodeView = [clickedView]; } else { const index = currentNodeView.indexOf(clickedView); if (index > -1) { currentNodeView.splice(index, 1); } else { currentNodeView.push(clickedView); } } }
            if (!isAggregate) { if (currentNodeView.length === 0) { currentNodeView = ['Aggregate']; } else if (currentNodeView.length === availableNodes.length) { currentNodeView = ['Aggregate']; } }
            renderNodeSelector();
            heatmap.clearData();
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'set_view', view: currentNodeView }));
                if (performanceState.range !== '5m') { document.querySelector('#time-range-toggles [data-range="5m"]').click(); } else { ws.send(JSON.stringify({ type: 'get_historical_performance', view: currentNodeView, points: MAX_PERF_POINTS, interval_sec: PERFORMANCE_INTERVAL_MS / 1000 })); }
                requestHashstoreData(); // Request new hashstore data for the new view
            }
        });
        const mapCard = document.getElementById('map-card');
        const toggleMapSizeBtn = document.getElementById('toggle-map-size-btn');
        toggleMapSizeBtn.addEventListener('click', () => { const isMaximized = mapCard.classList.toggle('maximized'); document.body.classList.toggle('map-maximized', isMaximized); if (isMaximized) { toggleMapSizeBtn.innerHTML = '&#x2924;'; toggleMapSizeBtn.title = 'Restore Map Size'; } else { toggleMapSizeBtn.innerHTML = '&#x26F6;'; toggleMapSizeBtn.title = 'Maximize Map'; } setTimeout(() => { map.invalidateSize(); }, 150); });

        // --- WebSocket Connection & Data Handling ---
        let ws;
        const connectionManager = { overlay: document.getElementById('connection-overlay'), reconnectDelay: 1000, maxReconnectDelay: 30000, connect: function() { const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'; ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`); ws.onopen = () => { this.overlay.style.display = 'none'; this.reconnectDelay = 1000; console.log("[WebSocket] Connection opened."); requestHashstoreData(); }; ws.onmessage = (event) => { const data = JSON.parse(event.data); if (data.type !== 'log_entry' && data.type !== 'performance_batch_update') { console.log(`[WebSocket] Received message type: ${data.type}`); } handleWebSocketMessage(data); }; ws.onclose = () => { this.overlay.style.display = 'flex'; setTimeout(() => this.connect(), this.reconnectDelay); this.reconnectDelay = Math.min(this.maxReconnectDelay, this.reconnectDelay * 2); console.warn(`[WebSocket] Connection closed. Reconnecting in ${this.reconnectDelay}ms.`); }; ws.onerror = err => { console.error("[WebSocket] Error:", err); ws.close(); }; } };

        function initializePerformanceData(nodes) {
            livePerformanceBins = {}; // Reset all data
            nodes.forEach(node => {
                livePerformanceBins[node] = {};
            });
            historicalPerformanceData = dataTemplate(); // For non-live views
        }

        function updatePerformanceChart() {
            if (!isCardVisible('performance-card')) return;
            try {
                const isLiveView = performanceState.range === '5m';
                const view = performanceState.view;
                let datasetsToShow = [];

                if (!isLiveView) {
                    const data = historicalPerformanceData[view];
                    if (view === 'concurrency') {
                        datasetsToShow.push({ label: 'Operations (per sec)', data: data[0] });
                    } else {
                        const isAvg = performanceState.agg === 'avg' && currentNodeView.length > 1;
                        const nodeCount = isAvg ? currentNodeView.length : 1;
                        datasetsToShow.push({ label: 'Ingress (Upload)', data: data[0].map(p => ({ x: p.x, y: p.y / nodeCount })) });
                        datasetsToShow.push({ label: 'Egress (Download)', data: data[1].map(p => ({ x: p.x, y: p.y / nodeCount })) });
                    }
                } else {
                    const binsToRender = livePerformanceBins[currentNodeView.join(',')] || {}; // Key is now composite
                    const sortedTimestamps = Object.keys(binsToRender).map(Number).sort((a,b) => a - b);
                    const sourceData = sortedTimestamps.map(ts => ({
                        x: new Date(ts),
                        source: binsToRender[ts]
                    }));

                    const interval_sec = PERFORMANCE_INTERVAL_MS / 1000;
                    const isAvg = performanceState.agg === 'avg' && currentNodeView.length > 1;
                    const nodeCount = isAvg ? (currentNodeView[0] === 'Aggregate' ? availableNodes.length : currentNodeView.length) : 1;

                    if (view === 'concurrency') {
                        const chartData = sourceData.map(p => ({ x: p.x, y: (p.source.total_ops / interval_sec) / nodeCount }));
                        datasetsToShow.push({ label: 'Operations (per sec)', data: chartData });
                    } else {
                        const chartDataIngress = sourceData.map(p => {
                            let y;
                            if (view === 'rate') y = ((p.source.ingress_bytes * 8) / (interval_sec * 1e6)) / nodeCount;
                            else if (view === 'volume') y = (p.source.ingress_bytes / 1e6) / nodeCount;
                            else y = p.source.ingress_pieces / nodeCount;
                            return { x: p.x, y: y };
                        });
                        const chartDataEgress = sourceData.map(p => {
                            let y;
                            if (view === 'rate') y = ((p.source.egress_bytes * 8) / (interval_sec * 1e6)) / nodeCount;
                            else if (view === 'volume') y = (p.source.egress_bytes / 1e6) / nodeCount;
                            else y = p.source.egress_pieces / nodeCount;
                            return { x: p.x, y: y };
                        });
                        datasetsToShow.push({ label: 'Ingress (Upload)', data: chartDataIngress });
                        datasetsToShow.push({ label: 'Egress (Download)', data: chartDataEgress });
                    }
                }

                // Common styling
                const baseStyle = { tension: 0.2 };
                datasetsToShow[0] = {...datasetsToShow[0], ...baseStyle, borderColor: UPLOAD_COLOR, backgroundColor: UPLOAD_COLOR};
                if (datasetsToShow.length > 1) {
                    datasetsToShow[1] = {...datasetsToShow[1], ...baseStyle, borderColor: DOWNLOAD_COLOR, backgroundColor: DOWNLOAD_COLOR};
                }

                performanceChartInstance.data.datasets = datasetsToShow;
                performanceChartInstance.update(isLiveView ? 'none' : undefined);
            } catch (error) {
                console.error("Error in updatePerformanceChart:", error);
            }
        }

        // --- Data Processing on Message ---
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'init':
                    availableNodes = data.nodes;
                    renderNodeSelector();
                    initializePerformanceData(data.nodes);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'get_historical_performance', view: currentNodeView, points: MAX_PERF_POINTS, interval_sec: PERFORMANCE_INTERVAL_MS / 1000 }));
                    }
                    break;
                case 'log_entry':
                    if (isCardVisible('map-card') && data.location && data.location.lat) {
                        heatmap.addDataPoint(data.location.lat, data.location.lon, data.size || 1000, data.action, data.action, data.timestamp);
                    }
                    break;
                case 'performance_batch_update': {
                    const { node_name, bins } = data;
                    const updateNodeBins = (targetNodeName) => {
                        if (!livePerformanceBins[targetNodeName]) {
                            livePerformanceBins[targetNodeName] = {};
                        }
                        const targetBins = livePerformanceBins[targetNodeName];
                        for (const ts in bins) {
                            if (!targetBins[ts]) {
                                targetBins[ts] = { ingress_bytes: 0, egress_bytes: 0, ingress_pieces: 0, egress_pieces: 0, total_ops: 0 };
                            }
                            const binData = bins[ts];
                            targetBins[ts].ingress_bytes += binData.ingress_bytes || 0;
                            targetBins[ts].egress_bytes += binData.egress_bytes || 0;
                            targetBins[ts].ingress_pieces += binData.ingress_pieces || 0;
                            targetBins[ts].egress_pieces += binData.egress_pieces || 0;
                            targetBins[ts].total_ops += binData.total_ops || 0;
                        }
                    };
                    updateNodeBins(node_name);
                    updateNodeBins('Aggregate');

                    if (isCardVisible('performance-card') && performanceState.range === '5m') {
                        // New logic: Update the specific view's bins
                        const viewKey = currentNodeView.join(',');
                        if (currentNodeView.includes(node_name) || (currentNodeView.length === 1 && currentNodeView[0] === 'Aggregate')) {
                             if (!livePerformanceBins[viewKey]) livePerformanceBins[viewKey] = {};
                             const targetBins = livePerformanceBins[viewKey];
                             for (const ts in bins) {
                                 if (!targetBins[ts]) targetBins[ts] = { ingress_bytes: 0, egress_bytes: 0, ingress_pieces: 0, egress_pieces: 0, total_ops: 0 };
                                 Object.keys(bins[ts]).forEach(k => targetBins[ts][k] = (targetBins[ts][k] || 0) + bins[ts][k]);
                             }
                        }
                        clearTimeout(chartUpdateTimer);
                        chartUpdateTimer = setTimeout(updatePerformanceChart, 250);
                    }
                    break;
                }
                case 'historical_performance_data': {
                    const viewKey = Array.isArray(data.view) ? data.view.join(',') : data.view;
                    const bins = {};
                    const binSize = PERFORMANCE_INTERVAL_MS;

                    data.performance_data.forEach(p => {
                        const ts = new Date(p.timestamp).getTime();
                        const binnedTimestamp = Math.floor(ts / binSize) * binSize;
                        bins[binnedTimestamp] = {
                            ingress_bytes: p.ingress_bytes, egress_bytes: p.egress_bytes,
                            ingress_pieces: p.ingress_pieces, egress_pieces: p.egress_pieces,
                            total_ops: p.total_ops
                        };
                    });
                    livePerformanceBins[viewKey] = bins;

                    if (isCardVisible('performance-card') && viewKey === currentNodeView.join(',') && performanceState.range === '5m') {
                        updatePerformanceChart();
                    }
                    break;
                }
                case 'aggregated_performance_data':
                    historicalPerformanceData = dataTemplate();
                    data.performance_data.forEach(point => { const ts = new Date(point.timestamp); historicalPerformanceData.rate[0].push({x:ts, y:point.ingress_mbps}); historicalPerformanceData.rate[1].push({x:ts, y:point.egress_mbps}); historicalPerformanceData.volume[0].push({x:ts, y:point.ingress_bytes / 1e6}); historicalPerformanceData.volume[1].push({x:ts, y:point.egress_bytes / 1e6}); historicalPerformanceData.pieces[0].push({x:ts, y:point.ingress_pieces}); historicalPerformanceData.pieces[1].push({x:ts, y:point.egress_pieces}); historicalPerformanceData.concurrency[0].push({x:ts, y:point.concurrency}); });
                    if (isCardVisible('performance-card')) {
                        updatePerformanceChart();
                    }
                    break;
                case 'stats_update':
                    updateAllVisuals(data);
                    break;
                case 'hashstore_updated':
                    console.log("[WebSocket] Hashstore data updated on server. Requesting new data.");
                    requestHashstoreData();
                    break;
                case 'hashstore_stats_data':
                    updateHashstorePanel(data.data);
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            createPerformanceChart();
            createHashstoreChart();
            connectionManager.connect();
            initializeDisplayMenu();
        });

        // --- Dark Mode Chart Handler ---
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        function handleThemeChange(isDarkMode) {
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#e0e0e0' : '#333';
            const tooltipBackgroundColor = isDarkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.95)';
            const tooltipBorderColor = isDarkMode ? '#555' : '#ccc';

            Chart.defaults.color = textColor;
            Chart.defaults.borderColor = gridColor;

            Object.values(Chart.instances).forEach(chart => {
                if(chart.options.plugins && chart.options.plugins.tooltip) {
                    const tooltip = chart.options.plugins.tooltip;
                    tooltip.backgroundColor = tooltipBackgroundColor;
                    tooltip.borderColor = tooltipBorderColor;
                    tooltip.borderWidth = 1;
                    tooltip.titleColor = textColor;
                    tooltip.bodyColor = textColor;
                    tooltip.footerColor = textColor;
                }
                chart.update();
            });
        }
        handleThemeChange(darkModeMediaQuery.matches);
        darkModeMediaQuery.addEventListener('change', e => handleThemeChange(e.matches));
    </script>
</body>
</html>
