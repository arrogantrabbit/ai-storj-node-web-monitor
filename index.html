<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storagenode Pro Monitor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; transition: background-color 0.3s, color 0.3s; }
        .container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 20px; max-width: 1800px; margin: auto; }
        .card { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; display: flex; flex-direction: column; transition: background-color 0.3s; }
        .header-card { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; margin-bottom: 0; flex-wrap: wrap; }
        h1 { margin: 0; font-size: 1.8em; color: #1c1e21; }
        #node-selector { font-size: 1em; padding: 8px; border-radius: 6px; }
        #node-selector .node-link { margin: 0 8px; text-decoration: none; color: #007bff; cursor: pointer; }
        #node-selector .node-link.active { font-weight: bold; text-decoration: underline; }

        h3 { border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        .card-title { margin-top: 0; }
        .card-content { flex-grow: 1; }

        #map-card { grid-column: 1 / 8; grid-row: 2 / 4; }
        #map { height: 620px; border-radius: 8px; background-color: #aad3df; }
        #stats-card { grid-column: 8 / 13; grid-row: 2 / 3; }
        #health-card { grid-column: 8 / 13; grid-row: 3 / 4; }
        #performance-card { grid-column: 1 / 7; grid-row: 4 / 5; }
        #satellite-card { grid-column: 7 / 13; grid-row: 4 / 5; }
        #analysis-card { grid-column: 1 / 7; grid-row: 5 / 6; }
        #pie-charts-card { grid-column: 7 / 13; grid-row: 5 / 6; display: flex; justify-content: space-around; }

        .stat { text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-label { font-size: 0.9em; color: #606770; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }

        .info-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        .info-table th, .info-table td { text-align: left; padding: 6px; border-bottom: 1px solid #eee; }
        .info-table th { color: #606770; }
        .info-table td.numeric { text-align: right; }
        .piece-id { font-family: monospace; font-size: 0.9em; }

        .pie-chart-container { width: 48%; }

        .chart-header { display: flex; justify-content: space-between; align-items: center; }
        .chart-header h3 { border-bottom: none; margin-bottom: 15px; }
        .toggle-link { font-size: 0.8em; cursor: pointer; text-decoration: none; color: #007bff; margin: 0 4px; }
        .toggle-link.active { font-weight: bold; text-decoration: underline; }
        #aggregation-toggles { text-align: right; margin-top: 4px; font-size: 0.9em; }


        .rate-good { color: #22c55e; }
        .rate-ok { color: #f59e0b; }
        .rate-bad { color: #ef4444; }

        /* --- Dark Mode --- */
        @media (prefers-color-scheme: dark) {
            body { background-color: #121212; color: #e0e0e0; }
            .card { background-color: #1e1e1e; box-shadow: none; border: 1px solid #333; }
            h1, h3 { color: #ffffff; }
            h3 { border-bottom-color: #444; }
            .stat-label { color: #888; }
            .info-table th, .info-table td { border-bottom-color: #333; }
            .info-table th { color: #aaa; }
            .toggle-link, #node-selector .node-link { color: #4dabf7; }
            #map { background-color: #333; }
            .leaflet-tile-pane { filter: invert(1) hue-rotate(180deg) brightness(95%) contrast(90%); }
        }
    </style>
</head>
<body>
    <div id="connection-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); color: white; display: none; justify-content: center; align-items: center; text-align: center; font-size: 1.5em; z-index: 10000;">
        <div><p>Connection Lost</p><p style="font-size: 0.6em;">Attempting to reconnect...</p></div>
    </div>
    <div class="container">
        <div class="card header-card">
            <h1>Storagenode Pro Monitor</h1>
            <div id="node-selector" title="Select a node to view or show an aggregate of all nodes">
                <span>Loading...</span>
            </div>
        </div>


        <div id="map-card" class="card"><h3 class="card-title">Live Traffic Heatmap</h3><div id="map"></div></div>

        <div id="stats-card" class="card">
            <h3 id="stats-title" class="card-title">Overall Success Rates & Speed</h3>
            <div class="stats-grid card-content">
                <div class="stat"><div id="dl-rate" class="stat-value">...%</div><div class="stat-label">Download Success</div><small>(<span id="dl-success">0</span> / <span id="dl-total">0</span>)</small></div>
                <div class="stat"><div id="ul-rate" class="stat-value">...%</div><div class="stat-label">Upload Success</div><small>(<span id="ul-success">0</span> / <span id="ul-total">0</span>)</small></div>
                <div class="stat"><div id="dl-speed" class="stat-value">... Mbps</div><div class="stat-label" id="dl-speed-label">Download Speed</div></div>
                <div class="stat"><div id="ul-speed" class="stat-value">... Mbps</div><div class="stat-label" id="ul-speed-label">Upload Speed</div></div>
            </div>
        </div>

        <div id="health-card" class="card">
             <h3 class="card-title">Node Health & History</h3>
             <div class="stats-grid">
                <div class="stat"><div id="audit-rate" class="stat-value">...%</div><div class="stat-label">Audit Success</div><small>(<span id="audit-success">0</span> / <span id="audit-total">0</span>)</small></div>
             </div>
             <table class="info-table" style="margin-top: 15px;">
                <thead><tr><th>Time</th><th style="text-align: right;">DL %</th><th style="text-align: right;">UL %</th><th style="text-align: right;">Audit %</th><th style="text-align: right;">DL Speed</th><th style="text-align: right;">UL Speed</th></tr></thead>
                <tbody id="history-body"></tbody>
            </table>
        </div>

        <div id="performance-card" class="card">
            <div class="chart-header">
                <h3 id="performance-title" class="card-title">Live Performance</h3>
                <div>
                     <div id="performance-toggles">
                        <a href="#" class="toggle-link active" data-view="rate">Rate (Mbps)</a> | <a href="#" class="toggle-link" data-view="volume">Volume (MB)</a> | <a href="#" class="toggle-link" data-view="pieces">Pieces</a> | <a href="#" class="toggle-link" data-view="concurrency">Concurrency</a>
                    </div>
                    <div id="aggregation-toggles">
                        <small>Aggregate:</small>
                        <a href="#" class="toggle-link active" data-agg="sum">Sum</a> |
                        <a href="#" class="toggle-link" data-agg="avg">Average</a>
                   </div>
                </div>
            </div>
            <div class="card-content"><canvas id="performanceChart"></canvas></div>
        </div>

        <div id="satellite-card" class="card">
            <div class="chart-header">
                <h3 id="satellite-title" class="card-title">Traffic by Satellite</h3>
                <a href="#" id="toggle-satellite-view" class="toggle-link">Show by Size</a>
            </div>
            <div class="card-content"><canvas id="satelliteChart"></canvas></div>
        </div>

        <div id="analysis-card" class="card">
            <h3 class="card-title">Network & Error Analysis</h3>
            <div class="stats-grid card-content">
                <div>
                    <h5>Top 5 Errors</h5>
                    <table class="info-table"><tbody id="error-body"></tbody></table>
                </div>
                <div>
                    <h5>Top 5 Hot Pieces</h5>
                    <table class="info-table"><tbody id="pieces-body"></tbody></table>
                </div>
                 <div>
                    <h5>Top 5 Countries (Egress)</h5>
                    <table class="info-table"><tbody id="countries-dl-body"></tbody></table>
                </div>
                 <div>
                    <h5>Top 5 Countries (Ingress)</h5>
                    <table class="info-table"><tbody id="countries-ul-body"></tbody></table>
                </div>
            </div>
        </div>

        <div id="pie-charts-card" class="card">
            <div class="pie-chart-container"><h3 id="dl-pie-title">Download Sizes</h3><canvas id="downloadPieChart"></canvas></div>
            <div class="pie-chart-container"><h3 id="ul-pie-title">Upload Sizes</h3><canvas id="uploadPieChart"></canvas></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // --- Map Setup ---
        const map = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors', maxZoom: 18 }).addTo(map);
        const heatLayer = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 10, gradient: {0.4: 'blue', 0.65: 'lime', 1: 'red'} }).addTo(map);
        let heatPoints = [];

        // --- Constants & State ---
        const DOWNLOAD_COLOR = '#0ea5e9'; const UPLOAD_COLOR = '#22c55e';
        const PIE_CHART_COLORS = ['#36A2EB', '#FF6384', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED'];
        const PERFORMANCE_INTERVAL_MS = 2000;
        const MAX_PERF_POINTS = 150;
        let satelliteViewIsBySize = false; let lastSatelliteData = [];
        let performanceChartView = 'rate';
        let performanceAggregationMode = 'sum';
        let performanceData = {}; // Structured as { nodeName: { rate: [[],[]], ... }, ... }
        let aggregatedPerformanceData = {};
        let currentNodeView = 'Aggregate';
        let availableNodes = [];

        // --- Helper Functions ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024; const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
        function getRateClass(rate) {
            if (rate > 99.5) return 'rate-good';
            if (rate > 95) return 'rate-ok';
            return 'rate-bad';
        }

        const SATELLITE_NAMES = { '121RTSDpyNZVcEU84Ticf2L1ntiuUimbWgfATz21tuvgk3vzoA6': 'ap1', '12EayRS2V1kEsWESU9QMRseFhdxYxKicsiFmxrsLZHeLUtdps3S': 'us1', '12L9ZFwhzVpuEKMUNUqkaTLGzwY9G24tbiigLiXpmZWKwmcNDDs': 'eu1', '1wFTAgs9DP5RSnCqKV1eLf6N9wtk4EAtmN5DpSxcs8EjT69tGE': 'saltlake' };

        // --- Chart Initialization ---
        const performanceChart = new Chart(document.getElementById('performanceChart').getContext('2d'), {
            type: 'line',
            data: { datasets: [{ label: 'Ingress (Upload)', data: [], borderColor: UPLOAD_COLOR, tension: 0.2 }, { label: 'Egress (Download)', data: [], borderColor: DOWNLOAD_COLOR, tension: 0.2 }] },
            options: { scales: { x: { type: 'time', time: { unit: 'minute' } }, y: { beginAtZero: true, title: { display: true, text: 'Mbps'} } } }
        });
        const satelliteChart = new Chart(document.getElementById('satelliteChart').getContext('2d'), {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Downloads/Audits', data: [], backgroundColor: DOWNLOAD_COLOR }] },
            options: {
                indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                scales: { x: { stacked: true }, y: { stacked: true } },
                plugins: {
                    tooltip: {
                        callbacks: {
                            footer: function(tooltipItems) {
                                const context = tooltipItems[0];
                                if (lastSatelliteData.length === 0 || context.dataIndex >= lastSatelliteData.length) return '';
                                const satData = lastSatelliteData[context.dataIndex];
                                const lines = [];
                                const totalDl = satData.downloads;
                                if (totalDl > 0) { lines.push(`DL Success: ${(satData.dl_success / totalDl * 100).toFixed(2)}% (${satData.dl_success}/${totalDl})`); }
                                const totalUl = satData.uploads;
                                if (totalUl > 0) { lines.push(`UL Success: ${(satData.ul_success / totalUl * 100).toFixed(2)}% (${satData.ul_success}/${totalUl})`); }
                                const totalAudit = satData.audits;
                                if (totalAudit > 0) { lines.push(`Audit Success: ${(satData.audit_success / totalAudit * 100).toFixed(2)}% (${satData.audit_success}/${totalAudit})`); }
                                return lines;
                            }
                        }
                    }
                }
            }
        });
        const downloadPieChart = new Chart(document.getElementById('downloadPieChart').getContext('2d'), { type: 'pie', data: { labels: [], datasets: [{ data: [], backgroundColor: PIE_CHART_COLORS }] }});
        const uploadPieChart = new Chart(document.getElementById('uploadPieChart').getContext('2d'), { type: 'pie', data: { labels: [], datasets: [{ data: [], backgroundColor: PIE_CHART_COLORS }] }});

        // --- UI Update Functions ---
        function updateAllVisuals(data) {
            updateOverallStats(data.overall);
            updateSatelliteChart(data.satellites);
            updatePieChart(downloadPieChart, data.download_sizes);
            updatePieChart(uploadPieChart, data.upload_sizes);
            updateTitles(data.first_event_iso, data.last_event_iso);
            updateHistoricalTable(data.historical_stats);
            updateAnalysisTables(data);
        }

        function updateOverallStats(stats) {
            const totalDownloads = stats.dl_success + stats.dl_fail;
            const totalUploads = stats.ul_success + stats.ul_fail;
            const totalAudits = stats.audit_success + stats.audit_fail;
            const dlRate = totalDownloads > 0 ? (stats.dl_success / totalDownloads * 100).toFixed(2) : '100.00';
            const ulRate = totalUploads > 0 ? (stats.ul_success / totalUploads * 100).toFixed(2) : '100.00';
            const auditRate = totalAudits > 0 ? (stats.audit_success / totalAudits * 100).toFixed(2) : '100.00';

            document.getElementById('dl-rate').textContent = `${dlRate}%`;
            document.getElementById('dl-rate').className = `stat-value ${getRateClass(parseFloat(dlRate))}`;
            document.getElementById('dl-success').textContent = stats.dl_success;
            document.getElementById('dl-total').textContent = totalDownloads;

            document.getElementById('ul-rate').textContent = `${ulRate}%`;
            document.getElementById('ul-rate').className = `stat-value ${getRateClass(parseFloat(ulRate))}`;
            document.getElementById('ul-success').textContent = stats.ul_success;
            document.getElementById('ul-total').textContent = totalUploads;

            document.getElementById('dl-speed').textContent = `${(stats.avg_egress_mbps || 0).toFixed(2)} Mbps`;
            document.getElementById('ul-speed').textContent = `${(stats.avg_ingress_mbps || 0).toFixed(2)} Mbps`;

            document.getElementById('audit-rate').textContent = `${auditRate}%`;
            document.getElementById('audit-rate').className = `stat-value ${getRateClass(parseFloat(auditRate))}`;
            document.getElementById('audit-success').textContent = stats.audit_success;
            document.getElementById('audit-total').textContent = totalAudits;
        }

        function updateSatelliteChart(satStats) {
            lastSatelliteData = satStats;
            satelliteChart.data.labels = satStats.map(s => SATELLITE_NAMES[s.satellite_id] || s.satellite_id.substring(0, 12));
            if (satelliteViewIsBySize) {
                satelliteChart.options.scales.x.title.text = 'Data Transferred';
                satelliteChart.data.datasets[0].data = satStats.map(s => s.total_upload_size);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.total_download_size);
                satelliteChart.data.datasets[0].label = 'Upload Size';
                satelliteChart.data.datasets[1].label = 'Download Size';
            } else {
                satelliteChart.options.scales.x.title.text = 'Pieces';
                satelliteChart.data.datasets[0].data = satStats.map(s => s.uploads);
                satelliteChart.data.datasets[1].data = satStats.map(s => s.downloads + s.audits);
                satelliteChart.data.datasets[0].label = 'Uploads';
                satelliteChart.data.datasets[1].label = 'Downloads/Audits';
            }
            satelliteChart.update();
        }

        function updatePieChart(chart, sizeData) {
            chart.data.labels = sizeData.map(d => d.bucket);
            chart.data.datasets[0].data = sizeData.map(d => d.count);
            chart.update();
        }

        function updateTitles(firstIso, lastIso) {
            const formatTime = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let timeWindowStr = "(Last 60 Mins)";
            if (firstIso && lastIso) { timeWindowStr = `(${formatTime(new Date(firstIso))} - ${formatTime(new Date(lastIso))})`; }

            const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`;
            document.getElementById('stats-title').textContent = `Overall Success Rates & Speed${viewName} ${timeWindowStr}`;
            document.getElementById('satellite-title').textContent = `Traffic by Satellite${viewName} ${timeWindowStr}`;
            document.getElementById('dl-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Download Speed' : 'Download Speed';
            document.getElementById('ul-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Upload Speed' : 'Upload Speed';
        }

        function updateHistoricalTable(history) {
            const tbody = document.getElementById('history-body');
            tbody.innerHTML = '';
            if (!history || history.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No historical data yet.</td></tr>'; return;
            }
            for (const hour of history) {
                const totalDl = hour.dl_success + hour.dl_fail, dlRate = totalDl > 0 ? (hour.dl_success / totalDl * 100) : 100;
                const totalUl = hour.ul_success + hour.ul_fail, ulRate = totalUl > 0 ? (hour.ul_success / totalUl * 100) : 100;
                const totalAudit = hour.audit_success + hour.audit_fail, auditRate = totalAudit > 0 ? (hour.audit_success / totalAudit * 100) : 100;
                const dlSpeed = hour.dl_mbps !== undefined ? hour.dl_mbps.toFixed(2) : '...';
                const ulSpeed = hour.ul_mbps !== undefined ? hour.ul_mbps.toFixed(2) : '...';

                const row = tbody.insertRow();
                row.innerHTML = `<td>${new Date(hour.hour_timestamp).toLocaleTimeString([], { hour: 'numeric' })}</td>
                    <td class="numeric ${getRateClass(dlRate)}">${dlRate.toFixed(2)}%</td>
                    <td class="numeric ${getRateClass(ulRate)}">${ulRate.toFixed(2)}%</td>
                    <td class="numeric ${getRateClass(auditRate)}">${auditRate.toFixed(2)}%</td>
                    <td class="numeric">${dlSpeed} Mbps</td>
                    <td class="numeric">${ulSpeed} Mbps</td>`;
            }
        }

        function updateAnalysisTables(data) {
            const errorBody = document.getElementById('error-body'); errorBody.innerHTML = '';
            data.error_categories.forEach(e => errorBody.innerHTML += `<tr><td>${e.reason}</td><td>${e.count}</td></tr>`);

            const piecesBody = document.getElementById('pieces-body'); piecesBody.innerHTML = '';
            data.top_pieces.forEach(p => piecesBody.innerHTML += `<tr><td class="piece-id">${p.id.substring(0,20)}...</td><td>${p.count}</td></tr>`);

            const countriesDlBody = document.getElementById('countries-dl-body'); countriesDlBody.innerHTML = '';
            data.top_countries_dl.forEach(c => countriesDlBody.innerHTML += `<tr><td>${c.country}</td><td>${formatBytes(c.size)}</td></tr>`);

            const countriesUlBody = document.getElementById('countries-ul-body'); countriesUlBody.innerHTML = '';
            data.top_countries_ul.forEach(c => countriesUlBody.innerHTML += `<tr><td>${c.country}</td><td>${formatBytes(c.size)}</td></tr>`);
        }

        function updatePerformanceChart() {
            const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`;
            const viewTitles = { rate: 'Live Performance (Mbps)', volume: 'Data Volume (MB)', pieces: 'Pieces', concurrency: 'Active Operations' };
            const yAxisTitles = { rate: 'Mbps', volume: 'MB', pieces: 'Count', concurrency: 'Concurrent Ops' };
            document.getElementById('performance-title').textContent = viewTitles[performanceChartView] + viewName;

            document.getElementById('aggregation-toggles').style.display = (currentNodeView === 'Aggregate') ? 'block' : 'none';

            const dataToDisplay = (currentNodeView === 'Aggregate') ? aggregatedPerformanceData : performanceData[currentNodeView];
            if (!dataToDisplay) return;

            let yAxisTitle = yAxisTitles[performanceChartView];
            if(currentNodeView === 'Aggregate' && performanceAggregationMode === 'avg') {
                yAxisTitle = yAxisTitle.replace('Mbps', 'Avg. Mbps').replace('MB', 'Avg. MB');
            } else if (currentNodeView === 'Aggregate' && performanceAggregationMode === 'sum') {
                 yAxisTitle = yAxisTitle.replace('Mbps', 'Total Mbps').replace('MB', 'Total MB');
            }
            performanceChart.options.scales.y.title.text = yAxisTitle;

            const isConcurrency = performanceChartView === 'concurrency';
            let datasetsToShow = [];

            if (isConcurrency) {
                // For Concurrency view, create a single dataset.
                datasetsToShow.push({
                    label: 'Operations',
                    data: dataToDisplay.concurrency ? dataToDisplay.concurrency[0] : [],
                    borderColor: UPLOAD_COLOR,
                    tension: 0.2
                });
            } else {
                // For all other views, create two datasets.
                datasetsToShow.push({
                    label: 'Ingress (Upload)',
                    data: dataToDisplay[performanceChartView] ? dataToDisplay[performanceChartView][0] : [],
                    borderColor: UPLOAD_COLOR,
                    tension: 0.2
                });
                datasetsToShow.push({
                    label: 'Egress (Download)',
                    data: dataToDisplay[performanceChartView] ? dataToDisplay[performanceChartView][1] : [],
                    borderColor: DOWNLOAD_COLOR,
                    tension: 0.2
                });
            }

            performanceChart.data.datasets = datasetsToShow;
            performanceChart.update('none');
        }

        function initializePerformanceData(nodes) {
            const dataTemplate = () => ({ rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[], []] });
            nodes.forEach(node => {
                performanceData[node] = dataTemplate();
            });
            aggregatedPerformanceData = dataTemplate();
        }

        function recalculateAggregateData() {
            const dataTemplate = () => ({ rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[], []] });
            const newAggData = dataTemplate();
            const nodeNames = availableNodes.filter(n => n !== 'Aggregate');
            if (nodeNames.length === 0) return;

            const allTimestamps = new Set();
            nodeNames.forEach(node => {
                Object.values(performanceData[node]).forEach(seriesPair => {
                    seriesPair[0].forEach(point => allTimestamps.add(point.x.getTime()));
                });
            });

            const sortedTimestamps = Array.from(allTimestamps).sort();

            sortedTimestamps.forEach(ts => {
                const timestamp = new Date(ts);
                Object.keys(newAggData).forEach(metric => {
                    const isConcurrency = metric === 'concurrency';
                    const numSeries = isConcurrency ? 1 : 2;
                    for (let i = 0; i < numSeries; i++) {
                        let sum = 0;
                        let count = 0;
                        nodeNames.forEach(node => {
                            const point = performanceData[node][metric][i].find(p => p.x.getTime() === ts);
                            if (point) {
                                sum += point.y;
                                count++;
                            }
                        });

                        if (count > 0) {
                            const value = performanceAggregationMode === 'avg' ? sum / count : sum;
                            newAggData[metric][i].push({ x: timestamp, y: value });
                        }
                    }
                });
            });
            aggregatedPerformanceData = newAggData;
            updatePerformanceChart();
        }


        // --- Event Listeners ---
        document.getElementById('toggle-satellite-view').addEventListener('click', function(e) {
            e.preventDefault();
            satelliteViewIsBySize = !satelliteViewIsBySize;
            this.textContent = satelliteViewIsBySize ? 'Show by Pieces' : 'Show by Size';
            updateSatelliteChart(lastSatelliteData);
        });

        document.getElementById('performance-toggles').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.tagName === 'A') {
                performanceChartView = e.target.getAttribute('data-view');
                document.querySelectorAll('#performance-toggles .toggle-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');
                updatePerformanceChart();
            }
        });

        document.getElementById('aggregation-toggles').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.tagName === 'A') {
                performanceAggregationMode = e.target.getAttribute('data-agg');
                document.querySelectorAll('#aggregation-toggles .toggle-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');
                recalculateAggregateData();
            }
        });

        document.getElementById('node-selector').addEventListener('click', function(e) {
            e.preventDefault();
            if (e.target.classList.contains('node-link')) {
                const newView = e.target.getAttribute('data-view');
                if (newView === currentNodeView) return;

                currentNodeView = newView;

                document.querySelectorAll('#node-selector .node-link').forEach(el => el.classList.remove('active'));
                e.target.classList.add('active');

                if (ws && ws.readyState === WebSocket.OPEN) {
                    Object.values(Chart.instances).forEach(chart => {
                        chart.data.datasets.forEach(dataset => dataset.data = []);
                        chart.update('none');
                    });
                    ws.send(JSON.stringify({ type: 'set_view', view: currentNodeView }));
                }
                updatePerformanceChart();
            }
        });

        // --- WebSocket Connection ---
        let ws;
        const connectionManager = {
            overlay: document.getElementById('connection-overlay'),
            reconnectDelay: 1000, maxReconnectDelay: 30000,
            connect: function() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);

                ws.onopen = () => { console.log("WebSocket established."); this.overlay.style.display = 'none'; this.reconnectDelay = 1000; };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    switch(data.type) {
                        case 'init':
                            availableNodes = data.nodes;
                            const selector = document.getElementById('node-selector');
                            selector.innerHTML = '';
                            data.nodes.forEach(name => {
                                const link = document.createElement('a');
                                link.href = '#';
                                link.className = 'node-link';
                                link.textContent = name;
                                link.setAttribute('data-view', name);
                                if (name === currentNodeView) {
                                    link.classList.add('active');
                                }
                                selector.appendChild(link);
                            });
                            initializePerformanceData(data.nodes.filter(n => n !== 'Aggregate'));
                            updatePerformanceChart();
                            break;
                        case 'log_entry':
                            if (data.location && data.location.lat) {
                                heatPoints.push([data.location.lat, data.location.lon, 0.5]);
                                if (heatPoints.length > 500) heatPoints.shift();
                                heatLayer.setLatLngs(heatPoints);
                            }
                            break;
                        case 'performance_update':
                            const { node_name, timestamp, ...metrics } = data;
                            const binnedTimestamp = Math.floor(new Date(timestamp).getTime() / PERFORMANCE_INTERVAL_MS) * PERFORMANCE_INTERVAL_MS;
                            const binnedNow = new Date(binnedTimestamp);

                            const nodePerf = performanceData[node_name];
                            if (!nodePerf) break;

                            const nodeNames = availableNodes.filter(n => n !== 'Aggregate');

                            function updateOrPushPoint(series, point) {
                                const lastPoint = series.length > 0 ? series[series.length - 1] : null;
                                if (lastPoint && lastPoint.x.getTime() === point.x.getTime()) {
                                    lastPoint.y = point.y;
                                } else {
                                    series.push(point);
                                }
                            }

                            const metricMap = {
                                rate: [metrics.ingress_mbps, metrics.egress_mbps],
                                volume: [metrics.ingress_bytes / 1e6, metrics.egress_bytes / 1e6],
                                pieces: [metrics.ingress_pieces, metrics.egress_pieces],
                                concurrency: [metrics.concurrency]
                            };

                            Object.keys(metricMap).forEach(metric => {
                                const values = metricMap[metric];
                                for(let i=0; i<values.length; i++) {
                                    updateOrPushPoint(nodePerf[metric][i], { x: binnedNow, y: values[i]});
                                }
                            });

                            Object.keys(aggregatedPerformanceData).forEach(metric => {
                                const isConcurrency = metric === 'concurrency';
                                const numSeries = isConcurrency ? 1 : 2;
                                for (let i = 0; i < numSeries; i++) {
                                    let sum = 0;
                                    let count = 0;
                                    nodeNames.forEach(node => {
                                        const series = performanceData[node][metric][i];
                                        const lastPoint = series.length > 0 ? series[series.length-1] : null;
                                        if(lastPoint && lastPoint.x.getTime() === binnedTimestamp) {
                                            sum += lastPoint.y;
                                            count++;
                                        }
                                    });
                                    if(count > 0) {
                                        const value = performanceAggregationMode === 'avg' ? sum / count : sum;
                                        updateOrPushPoint(aggregatedPerformanceData[metric][i], { x: binnedNow, y: value });
                                    }
                                }
                            });

                            Object.values(performanceData).forEach(nodePerf => {
                                for (const key in nodePerf) {
                                    while (nodePerf[key][0].length > MAX_PERF_POINTS) nodePerf[key][0].shift();
                                    if(nodePerf[key][1]) while (nodePerf[key][1].length > MAX_PERF_POINTS) nodePerf[key][1].shift();
                                }
                            });
                            for (const key in aggregatedPerformanceData) {
                                while (aggregatedPerformanceData[key][0].length > MAX_PERF_POINTS) aggregatedPerformanceData[key][0].shift();
                                if(aggregatedPerformanceData[key][1]) while (aggregatedPerformanceData[key][1].length > MAX_PERF_POINTS) aggregatedPerformanceData[key][1].shift();
                            }

                            updatePerformanceChart();
                            break;
                        case 'stats_update':
                            updateAllVisuals(data);
                            break;
                    }
                };

                ws.onclose = (event) => {
                    console.log(`WebSocket closed. Reconnecting...`);
                    this.overlay.style.display = 'flex';
                    setTimeout(() => this.connect(), this.reconnectDelay);
                    this.reconnectDelay = Math.min(this.maxReconnectDelay, this.reconnectDelay * 2);
                };

                ws.onerror = (err) => { console.error("WebSocket error:", err); ws.close(); };
            }
        };
        connectionManager.connect();

        // --- Dark Mode Chart Handler ---
        function updateChartColors(isDarkMode) {
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#e0e0e0' : '#333';

            Chart.defaults.color = textColor;
            Chart.defaults.borderColor = gridColor;

            for (const id in Chart.instances) {
                const chart = Chart.instances[id];
                if(chart.options.plugins.tooltip) {
                    chart.options.plugins.tooltip.titleColor = textColor;
                    chart.options.plugins.tooltip.bodyColor = textColor;
                    chart.options.plugins.tooltip.footerColor = textColor;
                }
                chart.update();
            }
        }

        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        updateChartColors(darkModeMediaQuery.matches);
        darkModeMediaQuery.addEventListener('change', e => updateChartColors(e.matches));
    </script>
</body>
</html>
