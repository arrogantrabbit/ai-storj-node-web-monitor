<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex">
    <title>Storagenode Pro Monitor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; transition: background-color 0.3s, color 0.3s; }
        .container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 20px; max-width: 1800px; margin: auto; }
        .card { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; display: flex; flex-direction: column; transition: background-color 0.3s; }
        .header-card { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; margin-bottom: 0; flex-wrap: wrap; }
        h1 { margin: 0; font-size: 1.8em; color: #1c1e21; }
        #node-selector { font-size: 1em; padding: 8px; border-radius: 6px; }
        #node-selector .node-link { margin: 0 8px; text-decoration: none; color: #007bff; cursor: pointer; }
        #node-selector .node-link.active { font-weight: bold; text-decoration: underline; }

        h3 { border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        h5 { margin-top: 0; margin-bottom: 10px; font-size: 1em; }
        .card-title { margin-top: 0; }
        .card-content { flex-grow: 1; }
        .table-container { overflow-x: auto; }

        #map-card { grid-column: 1 / 8; grid-row: 2 / 4; }
        #map { height: 620px; border-radius: 8px; background-color: #aad3df; }
        #stats-card { grid-column: 8 / 13; grid-row: 2 / 3; }
        #health-card { grid-column: 8 / 13; grid-row: 3 / 4; }
        #performance-card { grid-column: 1 / 7; grid-row: 4 / 5; }
        #satellite-card { grid-column: 7 / 13; grid-row: 4 / 5; }
        #analysis-card { grid-column: 1 / -1; grid-row: 5 / 6; }
        #size-charts-card { grid-column: 1 / -1; grid-row: 6 / 7; }
        #hashstore-card { grid-column: 1 / -1; grid-row: 7 / 8; }


        .stat { text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-label { font-size: 0.9em; color: #606770; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; }

        .info-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        .info-table th, .info-table td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; vertical-align: top; }
        .info-table th { color: #606770; font-weight: 600; }
        .info-table th.numeric, .info-table td.numeric { text-align: right; white-space: nowrap; }
        .piece-id { font-family: monospace; font-size: 0.9em; white-space: nowrap; }


        .chart-header { display: flex; justify-content: space-between; align-items: center; }
        .chart-header h3 { border-bottom: none; margin-bottom: 15px; }
        .toggle-link { font-size: 0.8em; cursor: pointer; text-decoration: none; color: #007bff; margin: 0 4px; }
        .toggle-link.active { font-weight: bold; text-decoration: underline; }
        .toggle-link.disabled { color: #888; cursor: not-allowed; text-decoration: none; }
        #aggregation-toggles { text-align: right; margin-top: 4px; font-size: 0.9em; }

        #analysis-card .stats-grid {
            grid-template-columns: 2.5fr 2fr 1.5fr 1.5fr;
            gap: 30px;
        }
        #analysis-card .reason-cell {
            white-space: normal;
            word-break: break-word;
        }
        #performance-card .card-content,
        #satellite-card .card-content {
            position: relative;
            height: 350px;
        }
        #size-charts-card .card-content {
            position: relative;
            height: 600px;
        }


        .rate-good { color: #22c55e; }
        .rate-ok { color: #f59e0b; }
        .rate-bad { color: #ef4444; }

        .card-header-flex { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 15px; }
        .card-header-flex .card-title { margin-bottom: 0; border-bottom: none; padding-bottom: 0; }
        #toggle-map-size-btn { background: none; border: 1px solid transparent; border-radius: 4px; cursor: pointer; font-size: 1.5em; padding: 0; line-height: 1; color: #606770; transition: background-color 0.2s; }
        #toggle-map-size-btn:hover { background-color: rgba(0,0,0,0.05); border-color: #ddd; }

        body.map-maximized { overflow: hidden; }

        #map-card.maximized { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; margin: 0; border-radius: 0; padding: 15px; box-sizing: border-box; }
        #map-card.maximized .card-header-flex { margin-bottom: 10px; }
        #map-card.maximized #map { height: calc(100% - 50px); }


        /* --- Dark Mode --- */
        @media (prefers-color-scheme: dark) {
            body { background-color: #121212; color: #e0e0e0; }
            .card { background-color: #1e1e1e; box-shadow: none; border: 1px solid #333; }
            h1, h3, h5 { color: #ffffff; }
            h3, .card-header-flex { border-bottom-color: #444; }
            .stat-label { color: #888; }
            .info-table th, .info-table td { border-bottom-color: #333; }
            .info-table th { color: #aaa; }
            .toggle-link, #node-selector .node-link { color: #4dabf7; }
            .toggle-link.disabled { color: #555; }
            #map { background-color: #333; }
            .leaflet-tile-pane { filter: invert(1) hue-rotate(180deg) brightness(95%) contrast(90%); }
            #toggle-map-size-btn { color: #aaa; }
            #toggle-map-size-btn:hover { background-color: rgba(255,255,255,0.1); border-color: #444; }
        }
    </style>
</head>
<body>
    <div id="connection-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); color: white; display: none; justify-content: center; align-items: center; text-align: center; font-size: 1.5em; z-index: 10000;">
        <div><p>Connection Lost</p><p style="font-size: 0.6em;">Attempting to reconnect...</p></div>
    </div>
    <div class="container">
        <div class="card header-card">
            <h1>Storagenode Pro Monitor</h1>
            <div id="node-selector" title="Select a node to view or show an aggregate of all nodes">
                <span>Loading...</span>
            </div>
        </div>


        <div id="map-card" class="card">
            <div class="card-header-flex">
                <h3 class="card-title">Live Traffic Heatmap</h3>
                <button id="toggle-map-size-btn" title="Maximize Map">&#x26F6;</button>
            </div>
            <div id="map"></div>
        </div>

        <div id="stats-card" class="card">
            <h3 id="stats-title" class="card-title">Overall Success Rates & Speed</h3>
            <div class="stats-grid card-content">
                <div class="stat"><div id="dl-rate" class="stat-value">...%</div><div class="stat-label">Download Success</div><small>(<span id="dl-success">0</span> / <span id="dl-total">0</span>)</small></div>
                <div class="stat"><div id="ul-rate" class="stat-value">...%</div><div class="stat-label">Upload Success</div><small>(<span id="ul-success">0</span> / <span id="ul-total">0</span>)</small></div>
                <div class="stat"><div id="dl-speed" class="stat-value">... Mbps</div><div class="stat-label" id="dl-speed-label">Download Speed</div></div>
                <div class="stat"><div id="ul-speed" class="stat-value">... Mbps</div><div class="stat-label" id="ul-speed-label">Upload Speed</div></div>
            </div>
        </div>

        <div id="health-card" class="card">
             <h3 class="card-title">Node Health & History</h3>
             <div class="stats-grid">
                <div class="stat"><div id="audit-rate" class="stat-value">...%</div><div class="stat-label">Audit Success</div><small>(<span id="audit-success">0</span> / <span id="audit-total">0</span>)</small></div>
                <div class="stat"><div class="stat-value">&nbsp;</div><div class="stat-label">&nbsp;</div></div>
             </div>
             <div class="table-container" style="margin-top: 15px;">
                 <table class="info-table">
                    <thead><tr><th>Time</th><th class="numeric">DL %</th><th class="numeric">UL %</th><th class="numeric">Audit %</th><th class="numeric">DL Speed</th><th class="numeric">UL Speed</th></tr></thead>
                    <tbody id="history-body"></tbody>
                </table>
             </div>
        </div>

        <div id="performance-card" class="card">
            <div class="chart-header">
                <h3 id="performance-title" class="card-title">Live Performance</h3>
                <div>
                     <div id="performance-toggles">
                        <a href="#" class="toggle-link active" data-view="rate">Rate (Mbps)</a> | <a href="#" class="toggle-link" data-view="volume">Volume (MB)</a> | <a href="#" class="toggle-link" data-view="pieces">Pieces</a> | <a href="#" class="toggle-link" data-view="concurrency">Concurrency</a>
                    </div>
                    <div id="time-range-toggles" style="text-align: right; font-size: 0.9em; margin-top: 4px;">
                        <small>Range:</small>
                        <a href="#" class="toggle-link active" data-range="5m">5m</a> |
                        <a href="#" class="toggle-link" data-range="30m">30m</a> |
                        <a href="#" class="toggle-link" data-range="1h">1h</a> |
                        <a href="#" class="toggle-link" data-range="6h">6h</a> |
                        <a href="#" class="toggle-link" data-range="24h">24h</a>
                    </div>
                    <div id="aggregation-toggles">
                        <small>Aggregate:</small>
                        <a href="#" class="toggle-link active" data-agg="sum">Sum</a> |
                        <a href="#" class="toggle-link" data-agg="avg">Average</a>
                   </div>
                </div>
            </div>
            <div class="card-content"><canvas id="performanceChart"></canvas></div>
        </div>

        <div id="satellite-card" class="card">
            <div class="chart-header">
                <h3 id="satellite-title" class="card-title">Traffic by Satellite</h3>
                <a href="#" id="toggle-satellite-view" class="toggle-link">Show by Size</a>
            </div>
            <div class="card-content"><canvas id="satelliteChart"></canvas></div>
        </div>

        <div id="analysis-card" class="card">
            <h3 class="card-title">Network & Error Analysis</h3>
            <div class="stats-grid card-content">
                <div>
                    <h5>Top 10 Errors</h5>
                    <table class="info-table">
                        <thead><tr><th>Reason</th><th class="numeric">Count</th></tr></thead>
                        <tbody id="error-body"></tbody>
                    </table>
                </div>
                <div>
                    <h5>Top 10 Hot Pieces</h5>
                    <table class="info-table">
                        <thead><tr><th>Piece ID</th><th class="numeric">Count</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="pieces-body"></tbody>
                    </table>
                </div>
                 <div>
                    <h5>Top 10 Countries (Egress)</h5>
                     <table class="info-table">
                        <thead><tr><th>Country</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="countries-dl-body"></tbody>
                    </table>
                </div>
                 <div>
                    <h5>Top 10 Countries (Ingress)</h5>
                     <table class="info-table">
                        <thead><tr><th>Country</th><th class="numeric">Size</th></tr></thead>
                        <tbody id="countries-ul-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="size-charts-card" class="card">
            <div class="chart-header">
                <h3 id="size-chart-title" class="card-title">Data Transfer Size Distribution</h3>
                <div>
                    <a href="#" id="toggle-size-view" class="toggle-link">Show Percentages</a>
                </div>
            </div>
            <div class="card-content"><canvas id="sizeBarChart"></canvas></div>
        </div>

        <div id="hashstore-card" class="card">
            <h3 id="hashstore-title" class="card-title">Hashstore Compaction Stats</h3>
            <div class="card-content table-container">
                <table class="info-table">
                    <thead>
                        <tr>
                            <th>Node</th>
                            <th>Satellite</th>
                            <th>Store</th>
                            <th>Last Run</th>
                            <th class="numeric">Duration</th>
                            <th class="numeric">Data Reclaimed</th>
                            <th class="numeric">Data Rewritten</th>
                            <th class="numeric">Table Load</th>
                            <th class="numeric">Trash %</th>
                        </tr>
                    </thead>
                    <tbody id="hashstore-body">
                        <tr><td colspan="9" style="text-align: center;">Waiting for hashstore compaction events...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // --- Advanced Heatmap Implementation ---
        class AdvancedHeatmap {
            constructor(map) {
                this.map = map;
                this.dataPoints = [];
                this.persistentHeatData = {}; // Grid-based accumulation
                this.canvas = null;
                this.ctx = null;
                this.viewMode = 'size'; // 'size' or 'pieces'
                this.maxDataAge = 5 * 60 * 1000; // 5 minutes for full visibility
                this.animationFrame = null;
                this.particleSystem = [];
                this.lastRenderTime = Date.now();
                this.gridSize = 0.5; // Degrees for heatmap grid

                this.setupCanvas();
                this.startAnimation();
            }

            setupCanvas() {
                // Create a custom pane for the heatmap
                if (!this.map.getPane('heatmapPane')) {
                    this.map.createPane('heatmapPane');
                    this.map.getPane('heatmapPane').style.zIndex = 650;
                }

                // Create canvas element
                this.canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer');
                this.ctx = this.canvas.getContext('2d');

                // Create Leaflet canvas layer
                this.canvasLayer = L.canvasLayer({
                    pane: 'heatmapPane'
                }).addTo(this.map);

                const self = this;
                this.canvasLayer.delegate({
                    onDrawLayer: function(info) {
                        self.render(info);
                    }
                });

                // Redraw on map events
                this.map.on('moveend zoomend resize', () => this.canvasLayer.needRedraw());
            }

            processEvent(event) {
                const now = Date.now();
                const point = {
                    lat: event.lat,
                    lon: event.lon,
                    size: event.size,
                    type: event.type,
                    timestamp: now, // Use current time for display purposes
                    pieces: 1,
                    isNew: true
                };

                this.dataPoints.push(point);

                // Add to persistent heatmap grid
                const gridKey = `${Math.floor(event.lat / this.gridSize) * this.gridSize}_${Math.floor(event.lon / this.gridSize) * this.gridSize}`;
                if (!this.persistentHeatData[gridKey]) {
                    this.persistentHeatData[gridKey] = {
                        lat: Math.floor(event.lat / this.gridSize) * this.gridSize,
                        lon: Math.floor(event.lon / this.gridSize) * this.gridSize,
                        value: 0,
                        timestamp: now
                    };
                }
                this.persistentHeatData[gridKey].value += this.viewMode === 'size' ? event.size : 1;
                this.persistentHeatData[gridKey].timestamp = now;

                // Add particle effect for new data
                this.addParticle(event.lat, event.lon, event.type);

                // Keep data points limited
                const cutoffTime = now - this.maxDataAge * 2;
                this.dataPoints = this.dataPoints.filter(p => p.timestamp > cutoffTime);

                // Clean old persistent data
                for (let key in this.persistentHeatData) {
                    if (now - this.persistentHeatData[key].timestamp > this.maxDataAge * 4) {
                        delete this.persistentHeatData[key];
                    }
                }

                this.canvasLayer.needRedraw();
            }

            clearData() {
                this.dataPoints = [];
                this.persistentHeatData = {};
                this.particleSystem = [];
                this.canvasLayer.needRedraw(); // Force a redraw to clear the canvas
            }

            // Simplified entry point for new data
            addDataPoint(lat, lon, size, type, action, timestamp) {
                 const event = {
                    lat, lon, size,
                    type: action.includes('GET') ? (action === 'GET_AUDIT' ? 'audit' : 'download') : 'upload',
                    action,
                    eventTimestamp: timestamp ? new Date(timestamp).getTime() : Date.now()
                };
                this.processEvent(event);
            }

            addParticle(lat, lon, type) {
                const colors = {
                    download: 'rgba(0, 200, 255, 0.8)',
                    upload: 'rgba(200, 255, 0, 0.8)',
                    audit: 'rgba(255, 150, 255, 0.8)'
                };

                this.particleSystem.push({
                    lat, lon,
                    color: colors[type],
                    size: 15,
                    opacity: 1,
                    timestamp: Date.now()
                });
            }

            render(info) {
                const ctx = info.canvas.getContext('2d');
                const bounds = this.map.getBounds();
                const zoom = this.map.getZoom();
                const now = Date.now();

                // Clear canvas
                ctx.clearRect(0, 0, info.canvas.width, info.canvas.height);

                // First, render persistent heatmap layer
                this.renderPersistentHeatmap(ctx, info, bounds, zoom, now);

                // Then render live points on top
                this.renderLivePoints(ctx, info, bounds, zoom, now);

                // Finally render particles
                this.renderParticles(ctx, info);

                ctx.globalAlpha = 1;
            }

            renderPersistentHeatmap(ctx, info, bounds, zoom, now) {
                if (zoom < 5) return;

                const heatmapRadius = this.getRadiusForZoom(zoom) * 2;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = info.canvas.width;
                tempCanvas.height = info.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                for (let key in this.persistentHeatData) {
                    const heat = this.persistentHeatData[key];
                    if (!bounds.contains([heat.lat, heat.lon])) continue;

                    const point = info.layer._map.latLngToContainerPoint([heat.lat, heat.lon]);
                    const age = now - heat.timestamp;
                    const ageFactor = Math.max(0.1, 1 - (age / (this.maxDataAge * 4)));

                    const maxValue = this.viewMode === 'size' ? 10000000 : 100;
                    const intensity = Math.min(1, Math.sqrt(heat.value / maxValue));

                    const gradient = tempCtx.createRadialGradient(point.x, point.y, 0, point.x, point.y, heatmapRadius);
                    gradient.addColorStop(0, `rgba(255, 255, 0, ${intensity * ageFactor * 0.75})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 0, ${intensity * ageFactor * 0.5})`);
                    gradient.addColorStop(0.6, `rgba(255, 100, 0, ${intensity * ageFactor * 0.25})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                    tempCtx.fillStyle = gradient;
                    tempCtx.fillRect(point.x - heatmapRadius, point.y - heatmapRadius, heatmapRadius * 2, heatmapRadius * 2);
                }

                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                ctx.globalCompositeOperation = isDarkMode ? 'screen' : 'lighter';
                ctx.globalAlpha = isDarkMode ? 1.0 : 0.7;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            }

            renderLivePoints(ctx, info, bounds, zoom, now) {
                const clusterThreshold = this.getClusterThreshold(zoom);
                const clusters = this.clusterPoints(this.dataPoints, clusterThreshold, bounds);
                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

                if (zoom <= 4) {
                    ctx.globalCompositeOperation = isDarkMode ? 'screen' : 'lighter';
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));

                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 50000000 : 500;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));

                        const radius = 50 + intensity * 50;
                        const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);

                        if (intensity > 0.7) {
                            gradient.addColorStop(0, `rgba(255, 0, 0, ${ageFactor * 0.6})`);
                            gradient.addColorStop(0.5, `rgba(255, 255, 0, ${ageFactor * 0.4})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else if (intensity > 0.4) {
                            gradient.addColorStop(0, `rgba(255, 255, 0, ${ageFactor * 0.5})`);
                            gradient.addColorStop(0.5, `rgba(0, 255, 0, ${ageFactor * 0.25})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, `rgba(0, 255, 255, ${ageFactor * 0.4})`);
                            gradient.addColorStop(0.5, `rgba(0, 0, 255, ${ageFactor * 0.2})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        }
                        ctx.fillStyle = gradient;
                        ctx.fillRect(point.x - radius, point.y - radius, radius * 2, radius * 2);
                    });
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    clusters.forEach(cluster => {
                        const point = info.layer._map.latLngToContainerPoint([cluster.lat, cluster.lon]);
                        const age = now - cluster.avgTimestamp;
                        const ageFactor = Math.max(0, 1 - (age / this.maxDataAge));
                        const value = this.viewMode === 'size' ? cluster.totalSize : cluster.count;
                        const maxValue = this.viewMode === 'size' ? 1000000 : 10;
                        const intensity = Math.min(1, Math.sqrt(value / maxValue));
                        const radius = 3 + intensity * 5;
                        const typeColors = { download: '#0099FF', upload: '#00FF00', audit: '#CC00FF' };
                        ctx.globalAlpha = ageFactor * 0.9;
                        ctx.fillStyle = typeColors[cluster.dominantType];
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        if (cluster.hasNew) {
                            ctx.globalAlpha = ageFactor * 0.5;
                            ctx.strokeStyle = typeColors[cluster.dominantType];
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, radius + 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    });
                }
            }

            renderParticles(ctx, info) {
                const now = Date.now();
                const particleLifetime = 2000;

                this.particleSystem = this.particleSystem.filter(particle => {
                    const age = now - particle.timestamp;
                    if (age > particleLifetime) return false;

                    const point = info.layer._map.latLngToContainerPoint([particle.lat, particle.lon]);
                    const progress = age / particleLifetime;
                    const size = particle.size * (1 + progress * 3);
                    const opacity = particle.opacity * (1 - progress);
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = 1.5; // Restored thinner line for original look
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.stroke(); // Only stroke, no fill
                    ctx.restore();
                    return true;
                });
            }

            clusterPoints(points, threshold, bounds) {
                const clusters = [];
                points.forEach(point => {
                    if (!bounds.contains([point.lat, point.lon])) return;
                    let merged = false;
                    for (let cluster of clusters) {
                        const dist = this.getDistance(point.lat, point.lon, cluster.lat, cluster.lon);
                        if (dist < threshold) {
                            cluster.count++;
                            cluster.totalSize += point.size;
                            cluster.lat = (cluster.lat * (cluster.count - 1) + point.lat) / cluster.count;
                            cluster.lon = (cluster.lon * (cluster.count - 1) + point.lon) / cluster.count;
                            cluster.avgTimestamp = (cluster.avgTimestamp * (cluster.count - 1) + point.timestamp) / cluster.count;
                            cluster.types[point.type] = (cluster.types[point.type] || 0) + 1;
                            cluster.dominantType = Object.keys(cluster.types).reduce((a, b) => cluster.types[a] > cluster.types[b] ? a : b);
                            if (point.isNew) cluster.hasNew = true;
                            merged = true;
                            break;
                        }
                    }
                    if (!merged) {
                        clusters.push({ lat: point.lat, lon: point.lon, count: 1, totalSize: point.size, avgTimestamp: point.timestamp, types: { [point.type]: 1 }, dominantType: point.type, hasNew: point.isNew });
                    }
                });
                return clusters;
            }

            getDistance(lat1, lon1, lat2, lon2) {
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            getRadiusForZoom = zoom => (zoom <= 2) ? 15 : (zoom <= 4) ? 12 : (zoom <= 6) ? 10 : (zoom <= 8) ? 8 : (zoom <= 10) ? 6 : (zoom <= 12) ? 5 : 4;
            getClusterThreshold = zoom => (zoom <= 2) ? 1000 : (zoom <= 4) ? 500 : (zoom <= 6) ? 200 : (zoom <= 8) ? 100 : (zoom <= 10) ? 50 : (zoom <= 12) ? 20 : 10;

            setViewMode(mode) { this.viewMode = mode; this.canvasLayer.needRedraw(); }

            startAnimation() {
                const animate = () => {
                    const now = Date.now();
                    this.dataPoints.forEach(p => { if (p.isNew && now - p.timestamp > 500) p.isNew = false; });
                    if (this.particleSystem.length > 0 || this.dataPoints.some(p => p.isNew)) { this.canvasLayer.needRedraw(); }
                    this.animationFrame = requestAnimationFrame(animate);
                };
                animate();
            }

            destroy() {
                if (this.animationFrame) cancelAnimationFrame(this.animationFrame);
                if (this.canvasLayer) this.map.removeLayer(this.canvasLayer);
            }
        }

        L.CanvasLayer = L.Layer.extend({
            options: { pane: 'overlayPane' },
            initialize: function(options) { L.setOptions(this, options); },
            onAdd: function(map) { this._map = map; this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-layer'); const size = this._map.getSize(); this._canvas.width = size.x; this._canvas.height = size.y; const animated = this._map.options.zoomAnimation && L.Browser.any3d; L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide')); map.getPane(this.options.pane).appendChild(this._canvas); map.on('move moveend resize zoomend', this._reset, this); if (map.options.zoomAnimation && L.Browser.any3d) { map.on('zoomanim', this._animateZoom, this); } this._reset(); },
            onRemove: function(map) { L.DomUtil.remove(this._canvas); map.off('moveend resize zoomend', this._reset, this); if (map.options.zoomAnimation) { map.off('zoomanim', this._animateZoom, this); } },
            delegate: function(del) { this._delegate = del; return this; },
            needRedraw: function() { if (!this._frame) { this._frame = L.Util.requestAnimFrame(this._redraw, this); } return this; },
            _redraw: function() { if (this._delegate && this._delegate.onDrawLayer) { const info = { layer: this, canvas: this._canvas, bounds: this._map.getBounds(), size: this._map.getSize(), topLeft: this._map.latLngToLayerPoint(this._map.getBounds().getNorthWest()) }; this._delegate.onDrawLayer(info); } this._frame = null; },
            _reset: function() { const topLeft = this._map.containerPointToLayerPoint([0, 0]); L.DomUtil.setPosition(this._canvas, topLeft); const size = this._map.getSize(); this._canvas.width = size.x; this._canvas.height = size.y; this._redraw(); },
            _animateZoom: function(e) { const scale = this._map.getZoomScale(e.zoom); const offset = this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min; L.DomUtil.setTransform(this._canvas, offset, scale); }
        });
        L.canvasLayer = options => new L.CanvasLayer(options);

        // --- Map Setup (Reverted to single tile layer) ---
        const map = L.map('map').setView([20, 0], 2);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 18
        }).addTo(map);

        const heatmap = new AdvancedHeatmap(map);

        const HeatmapControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) { const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control heatmap-control'); const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; container.innerHTML = `<style>.heatmap-control{background-color:${isDarkMode?'#1e1e1e':'white'};color:${isDarkMode?'#e0e0e0':'#333'};padding:10px;border-radius:4px;border:1px solid ${isDarkMode?'#444':'#ccc'}}.heatmap-control h4{margin:0 0 8px 0;font-size:13px;font-weight:bold}.heatmap-control label{display:block;cursor:pointer;margin:4px 0;font-size:12px}.legend-section{margin-top:12px;padding-top:8px;border-top:1px solid ${isDarkMode?'#444':'#ddd'}}.legend-item{display:flex;align-items:center;margin:3px 0;font-size:11px}.legend-color{width:16px;height:16px;margin-right:6px;border-radius:50%;border:1px solid ${isDarkMode?'#666':'#ccc'}}.legend-gradient{width:100%;height:10px;margin:4px 0;border-radius:2px;background:linear-gradient(to right,rgba(0,0,255,0.2),rgba(0,255,255,0.4),rgba(0,255,0,0.6),rgba(255,255,0,0.8),rgba(255,0,0,1))}</style><div><h4>Heatmap View</h4><label><input type="radio" name="heatview" value="size" checked> Data Size</label><label><input type="radio" name="heatview" value="pieces"> Piece Count</label></div><div class="legend-section"><h4>Legend</h4><div class="legend-item"><span class="legend-color" style="background:#0099FF"></span> <span>Downloads</span></div><div class="legend-item"><span class="legend-color" style="background:#00FF00"></span> <span>Uploads</span></div><div class="legend-item"><span class="legend-color" style="background:#CC00FF"></span> <span>Audits</span></div><div style="margin-top:8px"><div style="font-size:11px;margin-bottom:2px">Activity Heat:</div><div class="legend-gradient"></div><div style="font-size:10px;display:flex;justify-content:space-between"><span>Low</span> <span>High</span></div></div></div>`; container.addEventListener('change', e => { if (e.target.name === 'heatview') heatmap.setViewMode(e.target.value); }); window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => { const isDark = e.matches; container.style.backgroundColor = isDark ? '#1e1e1e' : 'white'; container.style.color = isDark ? '#e0e0e0' : '#333'; container.style.borderColor = isDark ? '#444' : '#ccc'; }); L.DomEvent.disableClickPropagation(container); L.DomEvent.disableScrollPropagation(container); return container; }
        });
        map.addControl(new HeatmapControl());

        // --- Constants & State ---
        const DOWNLOAD_COLOR = '#0ea5e9'; const UPLOAD_COLOR = '#22c55e';
        const PERFORMANCE_INTERVAL_MS = 2000;
        const MAX_PERF_POINTS = 150;
        let satelliteViewIsBySize = false; let lastSatelliteData = [];
        let performanceState = {
            view: 'rate', // rate, volume, pieces, concurrency
            range: '5m', // 5m, 30m, 1h, 6h, 24h
            agg: 'sum' // sum, avg
        };
        let livePerformanceData = {};
        let aggregatedPerformanceData = {};
        let historicalPerformanceData = {};
        let currentNodeView = 'Aggregate';
        let availableNodes = [];
        let performanceHistoryLoaded = {};
        let performanceChartInstance = null;

        // --- Helper Functions ---
        function formatBytes(bytes, decimals = 2) { if (!bytes || bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
        function getRateClass(rate) { if (rate > 99.5) return 'rate-good'; if (rate > 95) return 'rate-ok'; return 'rate-bad'; }
        const SATELLITE_NAMES = { '121RTSDpyNZVcEU84Ticf2L1ntiuUimbWgfATz21tuvgk3vzoA6': 'ap1', '12EayRS2V1kEsWESU9QMRseFhdxYxKicsiFmxrsLZHeLUtdps3S': 'us1', '12L9ZFwhzVpuEKMUNUqkaTLGzwY9G24tbiigLiXpmZWKwmcNDDs': 'eu1', '1wFTAgs9DP5RSnCqKV1eLf6N9wtk4EAtmN5DpSxcs8EjT69tGE': 'saltlake' };

        // --- Chart Initialization ---
        function createPerformanceChart() {
            if (performanceChartInstance) {
                performanceChartInstance.destroy();
            }
            const ctx = document.getElementById('performanceChart').getContext('2d');
            const isLiveView = performanceState.range === '5m';
            const chartType = isLiveView ? 'line' : 'bar';
            const options = { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { tooltipFormat: 'PP pp' } }, y: { beginAtZero: true, title: { display: true } } } };
            if (isLiveView) {
                options.scales.x.time.unit = 'minute';
            } else {
                options.scales.x.stacked = true;
                options.scales.y.stacked = true;
                options.plugins = {
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                try {
                                    if (!context || context.length === 0) return '';
                                    const d = new Date(context[0].parsed.x);
                                    const dataIndex = context[0].dataIndex;
                                    const dataset = context[0].chart.data.datasets[context[0].datasetIndex];
                                    let intervalMs = 0;
                                    if (dataIndex + 1 < dataset.data.length) {
                                        const nextPointX = dataset.data[dataIndex + 1].x;
                                        intervalMs = new Date(nextPointX).getTime() - d.getTime();
                                    } else if (dataIndex > 0) {
                                        const prevPointX = dataset.data[dataIndex - 1].x;
                                        intervalMs = d.getTime() - new Date(prevPointX).getTime();
                                    }
                                    if (intervalMs > 0) {
                                        const next_d = new Date(d.getTime() + intervalMs);
                                        const timeFormat = { hour: '2-digit', minute:'2-digit', second: '2-digit' };
                                        return `Interval: ${d.toLocaleTimeString([], timeFormat)} - ${next_d.toLocaleTimeString([], timeFormat)}`;
                                    }
                                    return d.toLocaleString();
                                } catch (e) {
                                    console.error("Tooltip title error:", e);
                                    return "Error";
                                }
                            }
                        }
                    }
                };
            }
            performanceChartInstance = new Chart(ctx, { type: chartType, data: { datasets: [] }, options: options });
        }
        const satelliteChart = new Chart(document.getElementById('satelliteChart').getContext('2d'), { type: 'bar', data: { labels: [], datasets: [{ label: 'Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Downloads/Audits', data: [], backgroundColor: DOWNLOAD_COLOR }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { stacked: true, title: { display: true, text: 'Pieces' } }, y: { stacked: true } }, plugins: { tooltip: { callbacks: { footer: function(tooltipItems) { const context = tooltipItems[0]; if (lastSatelliteData.length === 0 || context.dataIndex >= lastSatelliteData.length) return ''; const satData = lastSatelliteData[context.dataIndex]; const lines = []; const totalDl = satData.downloads; if (totalDl > 0) lines.push(`DL Success: ${(satData.dl_success/totalDl*100).toFixed(2)}% (${satData.dl_success}/${totalDl})`); const totalUl = satData.uploads; if (totalUl > 0) lines.push(`UL Success: ${(satData.ul_success/totalUl*100).toFixed(2)}% (${satData.ul_success}/${totalUl})`); const totalAudit = satData.audits; if (totalAudit > 0) lines.push(`Audit Success: ${(satData.audit_success/totalAudit*100).toFixed(2)}% (${satData.audit_success}/${totalAudit})`); return lines; } } } } } });
        const sizeBarChart = new Chart(document.getElementById('sizeBarChart').getContext('2d'), { type: 'bar', data: { labels: [], datasets: [{ label: 'Successful Downloads', data: [], backgroundColor: DOWNLOAD_COLOR }, { label: 'Successful Uploads', data: [], backgroundColor: UPLOAD_COLOR }, { label: 'Failed Downloads', data: [], backgroundColor: '#ef4444' }, { label: 'Failed Uploads', data: [], backgroundColor: '#f97316' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Size Bucket' }, stacked: true }, y: { title: { display: true, text: 'Count' }, stacked: true } }, plugins: { legend: { position: 'top' }, tooltip: { callbacks: { footer: function(tooltipItems) { const item = tooltipItems[0]; const datasetLabels = ['successful downloads', 'successful uploads', 'failed downloads', 'failed uploads']; return `${item.parsed.y} ${datasetLabels[item.datasetIndex]} in this size range`; } } } } } });
        let sizeViewIsPercentage = false;

        // --- UI Update Functions ---
        function updateAllVisuals(data) { updateOverallStats(data.overall); updateSatelliteChart(data.satellites); updateSizeBarChart(data.transfer_sizes); updateTitles(data.first_event_iso, data.last_event_iso); updateHistoricalTable(data.historical_stats); updateAnalysisTables(data); updateHashstorePanel(data.hashstore_stats); }
        function updateOverallStats(stats) { if (!stats || Object.keys(stats).length === 0) return; const totalDownloads = stats.dl_success + stats.dl_fail; const totalUploads = stats.ul_success + stats.ul_fail; const totalAudits = stats.audit_success + stats.audit_fail; const dlRate = totalDownloads > 0 ? (stats.dl_success / totalDownloads * 100).toFixed(2) : '100.00'; const ulRate = totalUploads > 0 ? (stats.ul_success / totalUploads * 100).toFixed(2) : '100.00'; const auditRate = totalAudits > 0 ? (stats.audit_success / totalAudits * 100).toFixed(2) : '100.00'; document.getElementById('dl-rate').textContent = `${dlRate}%`; document.getElementById('dl-rate').className = `stat-value ${getRateClass(parseFloat(dlRate))}`; document.getElementById('dl-success').textContent = stats.dl_success; document.getElementById('dl-total').textContent = totalDownloads; document.getElementById('ul-rate').textContent = `${ulRate}%`; document.getElementById('ul-rate').className = `stat-value ${getRateClass(parseFloat(ulRate))}`; document.getElementById('ul-success').textContent = stats.ul_success; document.getElementById('ul-total').textContent = totalUploads; document.getElementById('dl-speed').textContent = `${(stats.avg_egress_mbps||0).toFixed(2)} Mbps`; document.getElementById('ul-speed').textContent = `${(stats.avg_ingress_mbps||0).toFixed(2)} Mbps`; document.getElementById('audit-rate').textContent = `${auditRate}%`; document.getElementById('audit-rate').className = `stat-value ${getRateClass(parseFloat(auditRate))}`; document.getElementById('audit-success').textContent = stats.audit_success; document.getElementById('audit-total').textContent = totalAudits; }
        function updateSatelliteChart(satStats) { if (!satStats) return; lastSatelliteData = satStats; satelliteChart.data.labels = satStats.map(s => SATELLITE_NAMES[s.satellite_id] || s.satellite_id.substring(0, 12)); if (satelliteViewIsBySize) { satelliteChart.options.scales.x.title.text = 'Data Transferred'; satelliteChart.data.datasets[0].data = satStats.map(s => s.total_upload_size); satelliteChart.data.datasets[1].data = satStats.map(s => s.total_download_size); satelliteChart.data.datasets[0].label = 'Upload Size'; satelliteChart.data.datasets[1].label = 'Download Size'; } else { satelliteChart.options.scales.x.title.text = 'Pieces'; satelliteChart.data.datasets[0].data = satStats.map(s => s.uploads); satelliteChart.data.datasets[1].data = satStats.map(s => s.downloads + s.audits); satelliteChart.data.datasets[0].label = 'Uploads'; satelliteChart.data.datasets[1].label = 'Downloads/Audits'; } satelliteChart.update(); }
        let lastTransferSizes = []; function updateSizeBarChart(transferSizes) { if (!transferSizes) return; lastTransferSizes = transferSizes; const allBuckets = ["< 1 KB", "1-4 KB", "4-16 KB", "16-64 KB", "64-256 KB", "256 KB - 1 MB", "> 1 MB"]; const successfulDownloadData = new Array(allBuckets.length).fill(0); const successfulUploadData = new Array(allBuckets.length).fill(0); const failedDownloadData = new Array(allBuckets.length).fill(0); const failedUploadData = new Array(allBuckets.length).fill(0); transferSizes.forEach(item => { const index = allBuckets.indexOf(item.bucket); if (index !== -1) { successfulDownloadData[index] = item.downloads_success; successfulUploadData[index] = item.uploads_success; failedDownloadData[index] = item.downloads_failed; failedUploadData[index] = item.uploads_failed; } }); if (sizeViewIsPercentage) { const totalAll = successfulDownloadData.reduce((s,v)=>s+v,0)+successfulUploadData.reduce((s,v)=>s+v,0)+failedDownloadData.reduce((s,v)=>s+v,0)+failedUploadData.reduce((s,v)=>s+v,0); if (totalAll > 0) { for (let i = 0; i < allBuckets.length; i++) { successfulDownloadData[i] = (successfulDownloadData[i]/totalAll*100).toFixed(1); successfulUploadData[i] = (successfulUploadData[i]/totalAll*100).toFixed(1); failedDownloadData[i] = (failedDownloadData[i]/totalAll*100).toFixed(1); failedUploadData[i] = (failedUploadData[i]/totalAll*100).toFixed(1); } } sizeBarChart.options.scales.y.title.text = 'Percentage (%)'; } else { sizeBarChart.options.scales.y.title.text = 'Count'; } sizeBarChart.data.labels = allBuckets; sizeBarChart.data.datasets[0].data = successfulDownloadData; sizeBarChart.data.datasets[1].data = successfulUploadData; sizeBarChart.data.datasets[2].data = failedDownloadData; sizeBarChart.data.datasets[3].data = failedUploadData; sizeBarChart.update(); }
        function updateTitles(firstIso, lastIso) { const formatTime = date => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); let timeWindowStr = "(Last 60 Mins)"; if (firstIso && lastIso) { timeWindowStr = `(${formatTime(new Date(firstIso))} - ${formatTime(new Date(lastIso))})`; } const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`; document.getElementById('stats-title').textContent = `Overall Success Rates & Speed${viewName} ${timeWindowStr}`; document.getElementById('satellite-title').textContent = `Traffic by Satellite${viewName} ${timeWindowStr}`; document.getElementById('size-chart-title').textContent = `Data Transfer Size Distribution${viewName} ${timeWindowStr}`; document.getElementById('hashstore-title').textContent = `Hashstore Compaction Stats${viewName}`; document.getElementById('dl-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Download Speed' : 'Download Speed'; document.getElementById('ul-speed-label').textContent = currentNodeView === 'Aggregate' ? 'Total Upload Speed' : 'Upload Speed'; }
        function updateHistoricalTable(history) { const tbody = document.getElementById('history-body'); tbody.innerHTML = ''; if (!history || history.length === 0) { tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No historical data yet.</td></tr>'; return; } for (const hour of history) { const totalDl = hour.dl_success + hour.dl_fail, dlRate = totalDl > 0 ? (hour.dl_success / totalDl * 100) : 100; const totalUl = hour.ul_success + hour.ul_fail, ulRate = totalUl > 0 ? (hour.ul_success / totalUl * 100) : 100; const totalAudit = hour.audit_success + hour.audit_fail, auditRate = totalAudit > 0 ? (hour.audit_success / totalAudit * 100) : 100; const dlSpeed = hour.dl_mbps !== undefined ? hour.dl_mbps.toFixed(2) : '...'; const ulSpeed = hour.ul_mbps !== undefined ? hour.ul_mbps.toFixed(2) : '...'; const row = tbody.insertRow(); row.innerHTML = `<td>${new Date(hour.hour_timestamp).toLocaleTimeString([],{hour:'numeric'})}</td><td class="numeric ${getRateClass(dlRate)}">${dlRate.toFixed(2)}%</td><td class="numeric ${getRateClass(ulRate)}">${ulRate.toFixed(2)}%</td><td class="numeric ${getRateClass(auditRate)}">${auditRate.toFixed(2)}%</td><td class="numeric">${dlSpeed} Mbps</td><td class="numeric">${ulSpeed} Mbps</td>`; } }
        function updateAnalysisTables(data) { const errorBody = document.getElementById('error-body'); errorBody.innerHTML = ''; if (data.error_categories && data.error_categories.length > 0) { data.error_categories.forEach(e => { errorBody.innerHTML += `<tr><td class="reason-cell">${e.reason}</td><td class="numeric">${e.count}</td></tr>`; }); } else { errorBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No errors in this time window.</td></tr>'; } const piecesBody = document.getElementById('pieces-body'); piecesBody.innerHTML = ''; if (data.top_pieces && data.top_pieces.length > 0) { data.top_pieces.forEach(p => { piecesBody.innerHTML += `<tr><td class="piece-id">${p.id.substring(0,25)}...</td><td class="numeric">${p.count}</td><td class="numeric">${formatBytes(p.size)}</td></tr>`; }); } else { piecesBody.innerHTML = '<tr><td colspan="3" style="text-align: center;">No data in this time window.</td></tr>'; } const countriesDlBody = document.getElementById('countries-dl-body'); countriesDlBody.innerHTML = ''; if (data.top_countries_dl && data.top_countries_dl.length > 0) { data.top_countries_dl.forEach(c => countriesDlBody.innerHTML += `<tr><td>${c.country}</td><td class="numeric">${formatBytes(c.size)}</td></tr>`); } else { countriesDlBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No data in this time window.</td></tr>'; } const countriesUlBody = document.getElementById('countries-ul-body'); countriesUlBody.innerHTML = ''; if (data.top_countries_ul && data.top_countries_ul.length > 0) { data.top_countries_ul.forEach(c => countriesUlBody.innerHTML += `<tr><td>${c.country}</td><td class="numeric">${formatBytes(c.size)}</td></tr>`); } else { countriesUlBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No data in this time window.</td></tr>'; } }
        function updateHashstorePanel(stats) { const tbody = document.getElementById('hashstore-body'); const showNodeColumn = currentNodeView === 'Aggregate'; document.querySelector('#hashstore-card th:first-child').style.display = showNodeColumn ? '' : 'none'; tbody.innerHTML = ''; if (!stats || stats.length === 0) { const colspan = showNodeColumn ? 9 : 8; tbody.innerHTML = `<tr><td colspan="${colspan}" style="text-align: center;">Waiting for hashstore compaction events...</td></tr>`; return; } for (const item of stats) { const row = tbody.insertRow(); let cellIndex = 0; if (showNodeColumn) { row.insertCell(cellIndex++).textContent = item.node_name; row.cells[0].style.display = ''; } else { row.insertCell(cellIndex++).style.display = 'none'; } row.insertCell(cellIndex++).textContent = SATELLITE_NAMES[item.satellite] || item.satellite.substring(0,12); row.insertCell(cellIndex++).textContent = item.store; row.insertCell(cellIndex++).textContent = new Date(item.last_run_iso).toLocaleTimeString(); const durationCell = row.insertCell(cellIndex++); durationCell.className = 'numeric'; durationCell.textContent = `${item.duration.toFixed(1)}s`; const reclaimedCell = row.insertCell(cellIndex++); reclaimedCell.className = 'numeric'; reclaimedCell.textContent = formatBytes(item.data_reclaimed_bytes); const rewrittenCell = row.insertCell(cellIndex++); rewrittenCell.className = 'numeric'; rewrittenCell.textContent = formatBytes(item.data_rewritten_bytes); const loadCell = row.insertCell(cellIndex++); loadCell.className = 'numeric'; loadCell.textContent = `${item.table_load.toFixed(2)}%`; const trashCell = row.insertCell(cellIndex++); trashCell.className = 'numeric'; trashCell.textContent = `${item.trash_percent.toFixed(2)}%`; } }

        function dataTemplate() {
            return { rate: [[], []], volume: [[], []], pieces: [[], []], concurrency: [[]] };
        }

        function updatePerformanceChart() {
            try {
                const isLiveView = performanceState.range === '5m';
                let dataToDisplay;

                if (isLiveView) {
                    dataToDisplay = (currentNodeView === 'Aggregate') ? aggregatedPerformanceData : livePerformanceData[currentNodeView];
                } else {
                    dataToDisplay = historicalPerformanceData;
                }

                if (!dataToDisplay) { return; }

                if (isLiveView) { document.getElementById('performance-title').textContent = `Live Performance`; } else { document.getElementById('performance-title').textContent = `Performance History`; }
                if (!performanceChartInstance) createPerformanceChart();
                const viewName = currentNodeView === 'Aggregate' ? '' : ` (${currentNodeView})`;
                const viewTitles = { rate: 'Rate (Mbps)', volume: 'Data Volume (MB)', pieces: 'Pieces', concurrency: 'Active Operations' };
                const yAxisTitles = { rate: 'Mbps', volume: 'MB', pieces: 'Count', concurrency: 'Concurrent Ops' };
                document.getElementById('performance-title').textContent = viewTitles[performanceState.view] + viewName;
                document.getElementById('aggregation-toggles').style.display = (currentNodeView === 'Aggregate') ? 'block' : 'none';

                let yAxisTitle = yAxisTitles[performanceState.view]; if(currentNodeView === 'Aggregate' && performanceState.agg === 'avg') { yAxisTitle = yAxisTitle.replace('Mbps', 'Avg. Mbps').replace('MB', 'Avg. MB'); } else if (currentNodeView === 'Aggregate' && performanceState.agg === 'sum') { yAxisTitle = yAxisTitle.replace('Mbps', 'Total Mbps').replace('MB', 'Total MB'); }
                performanceChartInstance.options.scales.y.title.text = yAxisTitle;
                const isConcurrency = performanceState.view === 'concurrency';
                let datasetsToShow = [];
                if (isConcurrency) { datasetsToShow.push({ label: 'Operations', data: dataToDisplay.concurrency ? dataToDisplay.concurrency[0] : [], borderColor: UPLOAD_COLOR, tension: 0.2, backgroundColor: UPLOAD_COLOR });
                } else {
                    datasetsToShow.push({ label: 'Ingress (Upload)', data: dataToDisplay[performanceState.view] ? dataToDisplay[performanceState.view][0] : [], borderColor: UPLOAD_COLOR, tension: 0.2, backgroundColor: UPLOAD_COLOR });
                    datasetsToShow.push({ label: 'Egress (Download)', data: dataToDisplay[performanceState.view] ? dataToDisplay[performanceState.view][1] : [], borderColor: DOWNLOAD_COLOR, tension: 0.2, backgroundColor: DOWNLOAD_COLOR });
                }
                performanceChartInstance.data.datasets = datasetsToShow;
                performanceChartInstance.update(isLiveView ? 'none' : undefined);
            } catch (error) {
                console.error("[updatePerformanceChart] CRITICAL: Failed to update performance chart.", error);
            }
        }
        function initializePerformanceData(nodes) { nodes.forEach(node => { if (!livePerformanceData[node]) { livePerformanceData[node] = dataTemplate(); } if (!performanceHistoryLoaded[node]) { performanceHistoryLoaded[node] = false; } }); aggregatedPerformanceData = dataTemplate(); historicalPerformanceData = dataTemplate(); }

        // This is the efficient function for live aggregate updates.
        function updateAggregateData(timestamp, newMetrics) {
            const individualNodes = availableNodes.filter(n => n !== 'Aggregate');
            if (individualNodes.length === 0) return;

            Object.keys(newMetrics).forEach(metric => {
                const isConcurrency = metric === 'concurrency';
                const numSeries = isConcurrency ? 1 : 2;

                for (let i = 0; i < numSeries; i++) {
                    let sum = 0;
                    let count = 0;

                    // Sum up the values from all nodes for the given timestamp
                    individualNodes.forEach(node => {
                        const nodeSeries = livePerformanceData[node]?.[metric]?.[i];
                        if (nodeSeries) {
                            // Find the last point, as it's the most likely one to match
                            const lastPoint = nodeSeries[nodeSeries.length - 1];
                            if (lastPoint && lastPoint.x.getTime() === timestamp.getTime()) {
                                sum += lastPoint.y;
                                count++;
                            } else {
                                // If not the last point, search for it (less common case)
                                const point = nodeSeries.find(p => p.x.getTime() === timestamp.getTime());
                                if (point) {
                                    sum += point.y;
                                    count++;
                                }
                            }
                        }
                    });

                    if (count > 0) {
                        const value = (performanceState.agg === 'avg' && !isConcurrency) ? sum / count : sum;
                        const aggregateSeries = aggregatedPerformanceData[metric][i];
                        const newPoint = { x: timestamp, y: value };

                        // Use the same updateOrPush logic for the aggregate series
                        const lastAggPoint = aggregateSeries.length > 0 ? aggregateSeries[aggregateSeries.length - 1] : null;
                        if (lastAggPoint && lastAggPoint.x.getTime() === newPoint.x.getTime()) {
                            lastAggPoint.y = newPoint.y; // Update existing point
                        } else {
                            aggregateSeries.push(newPoint); // Add new point
                            if (aggregateSeries.length > MAX_PERF_POINTS) {
                                aggregateSeries.shift();
                            }
                        }
                    }
                }
            });
        }

        // This function is for full rebuilds, used when changing aggregation type (sum/avg)
        function rebuildAggregateData() {
            const newAggData = dataTemplate();
            const individualNodes = availableNodes.filter(n => n !== 'Aggregate');
            if (individualNodes.length === 0) return;

            const allTimestamps = new Set();
            individualNodes.forEach(node => {
                if(livePerformanceData[node]) {
                    Object.values(livePerformanceData[node]).forEach(seriesPair => {
                        seriesPair.forEach(series => {
                            series.forEach(point => allTimestamps.add(point.x.getTime()));
                        });
                    });
                }
            });

            const sortedTimestamps = Array.from(allTimestamps).sort((a,b) => a - b);
            sortedTimestamps.forEach(ts => {
                const timestamp = new Date(ts);
                Object.keys(newAggData).forEach(metric => {
                    const isConcurrency = metric === 'concurrency';
                    const numSeries = isConcurrency ? 1 : 2;
                    for (let i = 0; i < numSeries; i++) {
                        let sum = 0;
                        let count = 0;
                        individualNodes.forEach(node => {
                            const point = livePerformanceData[node]?.[metric]?.[i].find(p => p.x.getTime() === ts);
                            if (point) {
                                sum += point.y;
                                count++;
                            }
                        });
                        if (count > 0) {
                            const value = (performanceState.agg === 'avg' && metric !== 'concurrency') ? sum / count : sum;
                            newAggData[metric][i].push({ x: timestamp, y: value });
                        }
                    }
                });
            });
            aggregatedPerformanceData = newAggData;
        }

        // --- Event Listeners ---
        document.getElementById('toggle-satellite-view').addEventListener('click', function(e) { e.preventDefault(); satelliteViewIsBySize = !satelliteViewIsBySize; this.textContent = satelliteViewIsBySize ? 'Show by Pieces' : 'Show by Size'; updateSatelliteChart(lastSatelliteData); });
        document.getElementById('toggle-size-view').addEventListener('click', function(e) { e.preventDefault(); sizeViewIsPercentage = !sizeViewIsPercentage; this.textContent = sizeViewIsPercentage ? 'Show Counts' : 'Show Percentages'; updateSizeBarChart(lastTransferSizes); });
        document.getElementById('performance-toggles').addEventListener('click', function(e) { e.preventDefault(); if (e.target.tagName === 'A') { performanceState.view = e.target.getAttribute('data-view'); document.querySelectorAll('#performance-toggles .toggle-link').forEach(el => el.classList.remove('active')); e.target.classList.add('active'); updatePerformanceChart(); } });
        document.getElementById('time-range-toggles').addEventListener('click', function(e) {
            e.preventDefault();
            const newRange = e.target.getAttribute('data-range');
            if (newRange === performanceState.range) return;
            performanceState.range = newRange;

            document.querySelectorAll('#time-range-toggles .toggle-link').forEach(el => el.classList.remove('active'));
            e.target.classList.add('active');

            createPerformanceChart(); // Re-create chart for bar/line switch
            if (newRange === '5m') {
                updatePerformanceChart(); // Re-render with existing live data
            } else {
                const hours = { '30m': 0.5, '1h': 1, '6h': 6, '24h': 24 }[newRange];
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'get_aggregated_performance', view: currentNodeView, hours: hours }));
                }
            }
        });
        document.getElementById('aggregation-toggles').addEventListener('click', function(e) { e.preventDefault(); if (e.target.tagName === 'A') { performanceState.agg = e.target.getAttribute('data-agg'); document.querySelectorAll('#aggregation-toggles .toggle-link').forEach(el => el.classList.remove('active')); e.target.classList.add('active'); rebuildAggregateData(); updatePerformanceChart(); } });
        function requestInitialPerformance(view) { if (ws && ws.readyState === WebSocket.OPEN && view !== 'Aggregate') { ws.send(JSON.stringify({ type: 'get_historical_performance', view: view, points: MAX_PERF_POINTS, interval_sec: PERFORMANCE_INTERVAL_MS / 1000 })); } }

        document.getElementById('node-selector').addEventListener('click', function(e) {
             e.preventDefault();
             if (e.target.classList.contains('node-link')) {
                 const newView = e.target.getAttribute('data-view');
                 if (newView === currentNodeView) return;
                 currentNodeView = newView;
                 heatmap.clearData(); // Clear heatmap data on view change
                 document.querySelectorAll('#node-selector .node-link').forEach(el => el.classList.remove('active'));
                 e.target.classList.add('active');
                 ws.send(JSON.stringify({ type: 'set_view', view: newView }));

                 // Always reset to 5m live view when switching node or to Aggregate
                 if (performanceState.range !== '5m') {
                    document.querySelector('#time-range-toggles [data-range="5m"]').click();
                 } else {
                    // If already on 5m, just clear and refetch data for the new node
                    if (newView !== 'Aggregate' && !performanceHistoryLoaded[newView]) {
                        requestInitialPerformance(newView);
                    } else {
                         updatePerformanceChart();
                    }
                 }
             }
        });
        const mapCard = document.getElementById('map-card');
        const toggleMapSizeBtn = document.getElementById('toggle-map-size-btn');
        toggleMapSizeBtn.addEventListener('click', () => { const isMaximized = mapCard.classList.toggle('maximized'); document.body.classList.toggle('map-maximized', isMaximized); if (isMaximized) { toggleMapSizeBtn.innerHTML = '&#x2924;'; toggleMapSizeBtn.title = 'Restore Map Size'; } else { toggleMapSizeBtn.innerHTML = '&#x26F6;'; toggleMapSizeBtn.title = 'Maximize Map'; } setTimeout(() => { map.invalidateSize(); }, 150); });

        // --- WebSocket Connection ---
        let ws; const connectionManager = { overlay: document.getElementById('connection-overlay'), reconnectDelay: 1000, maxReconnectDelay: 30000, connect: function() { const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'; ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`); ws.onopen = () => { this.overlay.style.display = 'none'; this.reconnectDelay = 1000; console.log("[WebSocket] Connection opened."); }; ws.onmessage = (event) => { const data = JSON.parse(event.data);
            // Optimized console logging
            if (data.type !== 'performance_update') {
                console.log(`[WebSocket] Received message type: ${data.type}`);
            }
            switch(data.type) {
                case 'init':
                    availableNodes = data.nodes;
                    const selector = document.getElementById('node-selector');
                    selector.innerHTML = '';
                    data.nodes.forEach(name => { const link = document.createElement('a'); link.href = '#'; link.className = 'node-link'; link.textContent = name; link.setAttribute('data-view', name); if (name === currentNodeView) link.classList.add('active'); selector.appendChild(link); });
                    initializePerformanceData(data.nodes);
                    availableNodes.filter(n => n !== 'Aggregate').forEach(nodeName => { requestInitialPerformance(nodeName); });
                    break;
                case 'log_entry':
                    if (data.location && data.location.lat) {
                        heatmap.addDataPoint(data.location.lat, data.location.lon, data.size || 1000, data.action, data.action, data.timestamp);
                    }
                    break;
                case 'performance_update':
                    const { node_name, ...metrics } = data;
                    if (!livePerformanceData[node_name]) {
                        console.warn(`[performance_update] Received update for uninitialized node: ${node_name}. Initializing now.`);
                        initializePerformanceData([node_name]);
                    }
                    const nodePerf = livePerformanceData[node_name];
                    const binnedTimestamp = Math.floor(new Date(metrics.timestamp).getTime() / PERFORMANCE_INTERVAL_MS) * PERFORMANCE_INTERVAL_MS;
                    const binnedNow = new Date(binnedTimestamp);

                    const metricMap = { rate: [metrics.ingress_mbps, metrics.egress_mbps], volume: [metrics.ingress_bytes / 1e6, metrics.egress_bytes / 1e6], pieces: [metrics.ingress_pieces, metrics.egress_pieces], concurrency: [metrics.concurrency] };
                    const updateOrPushPoint = (series, point) => { const lastPoint = series.length > 0 ? series[series.length - 1] : null; if (lastPoint && lastPoint.x.getTime() === point.x.getTime()) { lastPoint.y = point.y; } else { series.push(point); if (series.length > MAX_PERF_POINTS) { series.shift(); } } };

                    Object.keys(metricMap).forEach(metric => {
                        const values = metricMap[metric];
                        for (let i = 0; i < values.length; i++) {
                            updateOrPushPoint(nodePerf[metric][i], { x: binnedNow, y: values[i] });
                        }
                    });

                    updateAggregateData(binnedNow, metricMap);

                    if (performanceState.range === '5m') {
                        updatePerformanceChart();
                    }
                    break;
                case 'historical_performance_data':
                    const nodeName = data.view;
                    if (!livePerformanceData[nodeName]) { initializePerformanceData([nodeName]); }
                    const nodePerfData = livePerformanceData[nodeName];
                    Object.keys(nodePerfData).forEach(key => { nodePerfData[key][0] = []; nodePerfData[key][1] = []; });
                    data.performance_data.forEach(point => { const ts = new Date(point.timestamp); nodePerfData.rate[0].push({x:ts, y:point.ingress_mbps}); nodePerfData.rate[1].push({x:ts, y:point.egress_mbps}); nodePerfData.volume[0].push({x:ts, y:point.ingress_bytes / 1e6}); nodePerfData.volume[1].push({x:ts, y:point.egress_bytes / 1e6}); nodePerfData.pieces[0].push({x:ts, y:point.ingress_pieces}); nodePerfData.pieces[1].push({x:ts, y:point.egress_pieces}); nodePerfData.concurrency[0].push({x:ts, y:point.concurrency}); });
                    performanceHistoryLoaded[nodeName] = true;
                    rebuildAggregateData(); // Rebuild aggregate once after history is loaded
                    if (currentNodeView === nodeName && performanceState.range === '5m') { updatePerformanceChart(); }
                    break;
                case 'aggregated_performance_data':
                    historicalPerformanceData = dataTemplate();
                    data.performance_data.forEach(point => { const ts = new Date(point.timestamp); historicalPerformanceData.rate[0].push({x:ts, y:point.ingress_mbps}); historicalPerformanceData.rate[1].push({x:ts, y:point.egress_mbps}); historicalPerformanceData.volume[0].push({x:ts, y:point.ingress_bytes / 1e6}); historicalPerformanceData.volume[1].push({x:ts, y:point.egress_bytes / 1e6}); historicalPerformanceData.pieces[0].push({x:ts, y:point.ingress_pieces}); historicalPerformanceData.pieces[1].push({x:ts, y:point.egress_pieces}); historicalPerformanceData.concurrency[0].push({x:ts, y:point.concurrency}); });
                    updatePerformanceChart();
                    break;
                case 'stats_update':
                    updateAllVisuals(data);
                    break;
            }
        }; ws.onclose = () => { this.overlay.style.display = 'flex'; setTimeout(() => this.connect(), this.reconnectDelay); this.reconnectDelay = Math.min(this.maxReconnectDelay, this.reconnectDelay * 2); console.warn(`[WebSocket] Connection closed. Reconnecting in ${this.reconnectDelay}ms.`); }; ws.onerror = err => { console.error("[WebSocket] Error:", err); ws.close(); }; } };

        document.addEventListener('DOMContentLoaded', () => {
            createPerformanceChart();
            connectionManager.connect();
        });

        // --- Dark Mode Chart Handler ---
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        function handleThemeChange(isDarkMode) {
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#e0e0e0' : '#333';
            Chart.defaults.color = textColor; Chart.defaults.borderColor = gridColor;
            Object.values(Chart.instances).forEach(chart => {
                if(chart.options.plugins.tooltip) { chart.options.plugins.tooltip.titleColor = textColor; chart.options.plugins.tooltip.bodyColor = textColor; chart.options.plugins.tooltip.footerColor = textColor; }
                chart.update();
            });
        }
        handleThemeChange(darkModeMediaQuery.matches);
        darkModeMediaQuery.addEventListener('change', e => handleThemeChange(e.matches));
    </script>
</body>
</html>
